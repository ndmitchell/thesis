
%include thesis.fmt

\chapter{First-Order Reduction}

The Core language presented in \S\ref{sec:core} is higher-order, but to simplify the analysis in Catch (Chapter \ref{chp:catch}), we work with a first-order language. This chapter gives alternative methods for removing higher-order constructs. For the purposes of this work, we require a transformation that preserves the meaning of a program, but does not necessarily preserve the space behaviour. If such a transformation was done for optimisation purposes, then space behaviour would be critical, but for analysis it is unnecessary.

\section{First-order Core}

\begin{figure}
\begin{code}
prog  =  f |--> vs_ x

expr  =  v                                          {-" \text{  variable} "-}
      |  c xs_                                      {-" \text{  constructor} "-}
      |  f xs_                                      {-" \text{  function} "-}
      |  let v = x in y                             {-" \text{  let binding} "-}
      |  case x of {p_1 -> y_1 ; ... ; p_n -> y_n}  {-" \text{  case expression} "-}
      |  v @ xs_                                    {-" \text{  variable application} "-}

pat   =  c vs_
\end{code}
\caption{First-order Core syntax}
\label{fig:fo_core}
\end{figure}

The first-order Core (FO-Core) language is given in Figure \ref{fig:fo_core}, and is based on the original higher-order Core (HO-Core) given in Figure \ref{fig:core}. The first difference is that a FO-Core program is a mapping of function names to a list of variables and an expression. Compared to the HO-Core, |f| mapping to |vs_ x| would be equivalent to |f| mapping to |\vs_ -> x|. The expression now has vector application for constructors and functions, all of which must be fully saturated. There is no longer a general application construct, or a lambda abstraction.

There is one new construct, variable application, written |v @ xs_| which applies the expressions |xs_| to the higher-order function bound to variable |v|. If a program has any |@| expressions within it, then it is no longer first-order. By permitting |@| expressions to appear, and relaxing the requirement that |f xs_| is saturated, we obtain a higher-order language which is suitable for transforming to first-order.

To convert from HO-Core to FO-Core we need to remove some features. Non-saturated constructors can be removed by adding a lambda which fully saturates the constructor. The removal of the lambda expression can be achieved using lambda lifting \cite{lambda_lift}, which replaces lambda's in expressions with top-level lambda abstractions. Applications to let expressions and case expressions can be removed using the case-app and let-app rules from Figure \ref{fig:simplify}.

The only remaining functional values in HO-Core are functions which are not immediately saturated with an application -- i.e. partial application. The only use of a higher-order function is an application to a variable. The partial application can be represented in FO-Core, and the application to a variable can be represented with an |@| expression.

\begin{figure}
\begin{code}
unsaturated :: Expr -> Bool
unsaturated v = False
unsaturated (c xs_) = False
unsaturated (f xs_) = arity f /= length xs_
unsaturated (let v = x in y) = unsaturated (y[v/x])
unsaturated (case x of alts_) = any f alts_
    where f (c vs_ -> y) = unsaturated y
unsaturated (v @ xs_) = False
\end{code}
\caption{Definition of which expressions are |unsaturated|.}
\label{fig:unsaturated}
\end{figure}

An expression is unsaturated it evaluates to a lambda expression. One way of checking this property is using the type system. An alternative approximation is using the |unsaturated| function in Figure \ref{fig:unsaturated}, which we use.

There are three methods available which remove higher order functions: Reynolds style defunctionalization, specialisation and super-specialisation. Of these, only Reynolds style is capable of removing all higher-order functions.

\section{Reynolds style defunctionalization}

Reynolds style defunctionalization \cite{reynolds:defunc} is the seminal method for generating a first-order equivalent of a higher-order program.

\begin{example}
\begin{code}
map f x = case  x of
                []      -> []
                (y:ys)  -> f y : map f ys
\end{code}

\noindent Defunctionalization works by creating a data type to represent all values that |f| may take anywhere in the whole program. For instance, it might be:

\ignore\begin{code}
data Function = Head | Tail

apply Head  x = head  x
apply Tail  x = tail  x

map f x = case  x of
                 []      -> []
                 (y:ys)  -> apply f a : map f as
\end{code}

\noindent Now all calls to |map head| are replaced by |map Head|.
\end{example}

This method naturally extends to partial application. To take a more complicated example, where higher-order functions are being used to store information:

\begin{example}
\begin{code}
type Map = String -> Int

new :: Map
new _ = 0

get :: String -> Map -> Int
get key mp = mp key

add :: String -> Int -> Map -> Map
add key val mp s = if s == key then val else get key mp

test = get "foo" (add "bar" 4 (add "baz" 2 new))
\end{code}

\noindent The above code creates a functional map, which uses a higher-order function to store a mapping from |String| to |Int|. The |add| function inserts a new key/value pair into the map. This is transformed with defunctionalization to:

\begin{code}
data Function  =  New
               |  Add3 String Int Function

apply  New                 x = new x
apply  (Add3 y_1 y_2 y_3)  x = add y_1 y_2 y_3 x

new _ = 0

get key mp = apply mp key

add key val mp s = if s == key then val else get key mp

test = get "foo" (Add3 "bar" 4 (Add3 "baz" 2 New))
\end{code}

Here we use the constructor |Add3| to represent the |add| function with three arguments pre-applied. Note that the |Function| data type now serves to store a linked-list of the values with |New| serving a similar role to |[]|, and |Add3| storing one key/value pair along with the remainder of the list.
\end{example}

Defunctionalized code is still type safe, but type checking would require a dependently typed language. The method is complete, removing all higher-order functions, and preserves space behaviour. The disadvantage is that the transformation essentially embeds a mini-interpreter for the original program into the new program. The flow control is complicated by the extra level of indirection.

A natural desire would be to eliminate the higher-order aspects of a program, without introducing any new data structures. However, it is simple to show that this transformation is not possible. Given a program, we can remove all data structures by Church encoding \cite{church_encode}. If we then had a transformation which made the program first-order \textit{without} introducing any data, we would end up with a program without data or closures, which is therefore incapable of storing an unbounded amount of information. Since with higher-order functions we can implement a Turing machine \cite{turing:halting}, and without an unbounded store we cannot, such a transformation cannot exist.

The two following methods both attempt to remove higher-order functions without introducing any additional data structures, and therefore are not complete. Reynold's method can always be used as a backup, if there are residual higher-order functions.


\section{Argument Specialisation}

The Catch tool presented in \cite{me:catch_tfp} uses specialisation to remove higher-order functions. For each application of a function to unsaturated arguments, a specialised variant is created, and used where applicable. The process follows the same pattern as constructor specialised \cite{spj:specconstr}, but applied to unsaturated expressions rather than known constructors. Examples of common functions whose applications can usually be made first-order include |map|, |filter|, |foldr| and |foldl|. When a function is specialised, the expression passed as the unsaturated argument has all its free variables passed as extra arguments, and is expanded in the specialised version. The specialisation proceeds in three steps:

\begin{enumerate}
\item Find all function calls with unsaturated arguments.
\item Generate specialised variants.
\item Replace calls with the specialised variants.
\end{enumerate}

\begin{example}
\begin{code}
adds x n = map ((+) n) x

map f xs = case  xs of
                 []    -> []
                 y:ys  -> f y : map f ys
\end{code}

\noindent The function |map| is called with the argument |((+) n)|, which is unsaturated. We generate the new function |map_adds| with the rule that |map_adds n x == map ((+) n) x|. We then convert all suitable applications to use |map_adds|.

\begin{code}
adds x n = map_adds n x

map_adds n xs = case  xs of
                      []    -> []
                      y:ys  -> (+) n y : map_adds n ys
\end{code}

An important point is that the transformation has also been made in the recursive call, making the entire fragment first-order.
\end{example}

The method used in \cite{me:catch_tfp} first identifies all invariant arguments, then generates specialised variants. If a specialised variant then invokes further functions with unsaturated arguments, they are not specialised -- the process is not repeated. Specialisation alone is sufficient for many examples, but it cannot cope with point-free code, and does not deal with many forms of dictionaries.

\section{Fixed Point of Specialisation}

A natural extension of specialisation is to take the fixed point. Unfortunately, such an algorithm would not terminate:

\begin{code}
dataWrap a= Wrap (Wrap a) | Value a
f x = f (Wrap x)
check = f (Value head)
\end{code}

\section{Inlining Unsaturated Functions}

\section{Specialisation with Inlining}



The power of specialisation is greatly increased if it is combined with inlining, and applied selectively to higher-order functions.

%if 0
\begin{figure}
\ignore\begin{code}
data Expr  =  ... -- as in Figure {\ref{fig:core}}
           |  Part   Int FuncName [Expr]
           |  Apply  Expr [Expr]

-- equivalences
Part 0 fn xs == Call fn xs
Apply (Part n fn xs) ys == Part (n - length ys) fn (xs ++ ys)
\end{code}
\caption{Augmented Core syntax.}
\label{fig:core_ho}
\end{figure}

In order to permit a higher-order program to be represented, the Core language is augmented with additional constructs, as shown in Figure \ref{fig:core_ho}. The |Apply| constructor represents an unsaturated function call, or a variable to be used as the function. The |Part| constructor is used to represent unsaturated function calls, leaving the normal |Call| constructor to represent saturated calls. A |Part| construction records how many arguments are needed.

\begin{figure}
\ignore\begin{code}
isHO :: Expr -> Bool
isHO (Part n _ _)    = n > 0
isHO (Make _ xs)     = any isHO xs
isHO (Case on alts)  = any (isHO . snd) alts
isHO _               = False
\end{code}
\caption{Tests for the firstifier.}
\label{fig:isHO}
\end{figure}

The algorithm for removing higher-order functions has two components, specialisation and inlining. We apply the specialise rule until a fixed point is reached, then apply the inline rule once. We repeat these two steps until a fixed point is reached. Given an appropriate |fix| function, |firstify| can be implemented as:

\ignore\begin{code}
firstify :: Program -> Program
firstify = fix (inline . fix specialise)
\end{code}

\paragraph{The |inline| stage} inlines each |Call| for which the body passes the |isHO| test, defined in Figure \ref{fig:isHO}. If this process causes a function to no longer be called from the root of the program, then the function is removed after inlining.

\paragraph{The |specialise| stage} takes every expression of the form |Call fn xs| where \ignore|any isHO xs|, and generates a specialised version of the function |fn| with all functional arguments in |xs| frozen in, and all others passed normally.

In rare circumstances a program may have an infinite number of specialisations. If necessary we revert to Reynolds style defunctionalization.

The combination of specialisation and inlining is powerful. We have encountered few examples where it fails -- mainly artificial tests created specifically to break the approach! In the definition of a higher-order function either the entire body is an application of the functional argument (in which case it will be inlined), or it must occur as the argument to a function (in which case it is specialised). There are only two places left for functional arguments to be used: (1) As the subject of a \ignore|case| expression. But this situation is impossible as all \ignore|case| expressions must choose over a data value. (2) Inside an |Apply| with another functional argument variable as the function. This situation is rare due to the removal of other functional arguments.

%endif
