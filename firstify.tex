
%include thesis.fmt

\chapter{First-Order Reduction}

This chapter deals with the reduction from a higher-order Core language to a primarily first-order Core language. Our motivation is that the Catch analysis tool (see Chapter \ref{chp:catch}) is designed to work only upon a first-order language, but our method may have use for other analysis tools, particularly termination checking \cite{serini:term,someone_else,someone_else}. The transformations presented in this chapter are all semantics preserving, but do \textit{not} all preserve sharing. As such, these transformations may not be suitable for optimisation, but are perfectly acceptable for analysis methods.


\section{Higher-Order Elements}

A program can be said to be higher-order if at runtime the program generates and manipulates functional values. In our Core language as currently defined, the expression |id 1| first evaluates |id| to a functional value, then applies the argument |1|. For our higher-order classification we treat a top-level function symbol and all statically given application arguments as one unit, meaning |id 1| is not a functional value.

\begin{example}
\label{ex:ho_elements}
The following two functions can be thought of as having functional elements:

\begin{code}
even = not . odd

map f x = case  x of
                []    -> []
                y:ys  -> f y : map f ys
\end{code}

The |even| function passes |not| and |odd| to the function |(.)|, both of which are functional values. In addition, the |(.)| function, when applied to only two arguments, returns a functional value. The definition of |map| does not create any functional values, but applies the variable |f| to an argument, suggesting that |f| is a functional value.
\end{example}

We classify higher-order elements as either \textit{creating} or \textit{applying} functional values.


\subsection{Creating Functional Values}

The most obvious way to create a functional value in our Core language is with an explicit lambda expression. The other way is to \textit{curry} or \textit{partially apply} a function, by passing fewer arguments than the arity of the function.

\begin{example}
\begin{code}
example1 = (\x -> x) 42

example2 xs = map id xs
\end{code}

Here |example1| contains an explicit lambda, which is a functional value. In |example2| the function |id| has an arity of 1, but is not given any arguments, and hence is a functional value.
\end{example}

It is possible for a program to have either one of these syntatic conditions, but at runtime, not create any functional values. Consider the following code:

\begin{code}
main = case  True of
             True   -> 1
             False  -> (\x -> x) 2
\end{code}

Here the |True| branch will always be taken due to the known case scrutinee. The |False| branch would create a functional value if taken, but as it will never be taken, this program will never create a functional value. This situation can be thought of as having functional elements in dead code.


\subsection{Applying Functional Values}

There are two ways to make use of functional values. The first is to apply an argument to an expression which is not a constructor or a top-level function. The second is to give a function more arguments than its associated arity.

\begin{example}
\begin{code}
example1 f = f 42

example2 = even 42
\end{code}

In |example1| the argument |f| is applied to the value 42, suggesting that |f| is functional. In |example2|, |even| is applied to one argument. Using the definition of |even| from Example \ref{ex:ho_elements}, with arity 0, this causes |even| to be given more arguments than its arity.
\end{example}

As before, we can construct an example where a functional value is applied, but which never occurs at runtime due to dead code. Another way of constructing an apparent application of a functional value is using |undefined| or a call to |error|.

\begin{example}
\begin{code}
main = error "bang" 42
\end{code}

Here the |error| primitive is being given two arguments, even though at first glance it appears to only take one. The is possible because the type of error is |String -> alpha|, where |alpha| is completely unconstrained and can be anything, including a functional type.
\end{example}


\subsection{First-Order Core}

We define a program to be first-order if it contains no expressions of the two types identified as creating functional values. In order to allow the property to be calculated statically, we ignore the issue of dead code. 

There exist programs, or fragments of code, which cannot be reduced to first-order. We present several examples in turn, explaining why a first-order reduction is not possible.

\begin{example}
\begin{code}
main = [id]
\end{code}

In this example, the |main| function returns a functional value inside a constructor. We cannot remove the functional value without changing the semantics of the |main| function, which is called from outside the our program, and hence cannot be altered. A related situation is:

\begin{code}
main = id
\end{code}

Here we can only reduce this program to first-order if we are allowed to increase the arity of |main| from zero to one. This situation occurs frequently in Haskell programs, whose |main| definition is typically of type |IO ()|. In the Yhc compiler, used to generate our Core language, the definition of |IO| is:

\begin{code}
newtype IO alpha = IO (World -> _E alpha)
\end{code}

At compilation time the |newtype| wrapper is removed, leaving a function from |World| to |_E alpha|. The |main| argument therefore takes a |World| parameter, before returning a first-order result. We permit the increasing of the arity of |main|.
\end{example}

\begin{example}
\begin{code}
main = id `seq` 42
\end{code}

Here a functional value (|id|) is passed to the primitive |seq|. As we are not able to peer inside the primitive, and must preserve its interface, we cannot remove this functional value. For most primitives, such as arithmetic operations, the types ensure that no functional values are passed as arguments. However, the |seq| primitive is of type |alpha -> beta -> beta|, allowing any type to be passed as either of the arguments, including functional values.

Another primitive which permits functional values is |primCatch :: alpha -> (beta -> alpha) -> alpha|. While |seq| merely permits functional values, |primCatch| actually \textit{requires} that the second argument is a functional value.
\end{example}

In both these examples, a functional value must be created as it is required by either the interface to a primitive, or the interface to the root function. In a similar manner, the root function may have a functional argument, or a primitive may return a functional value, resulting in a functional application.

If neither of the above cases occurs, then it is always possible to remove all function values from a Core program. One method for removing higher-order functions is Reynolds style defunctionalisation, which we detail first. Next we detail our method, which has some important differences from Reynold's method.


\section{Reynolds style defunctionalization}

Reynolds style defunctionalization \cite{reynolds:defunc} is the seminal method for generating a first-order equivalent of a higher-order program.

\begin{example}
\begin{code}
map f x = case  x of
                []      -> []
                (y:ys)  -> f y : map f ys
\end{code}

\noindent Defunctionalization works by creating a data type to represent all values that |f| may take anywhere in the whole program. For instance, it might be:

\ignore\begin{code}
data Function = Head | Tail

apply Head  x = head  x
apply Tail  x = tail  x

map f x = case  x of
                []    -> []
                y:ys  -> apply f a : map f as
\end{code}

\noindent Now all calls to |map head| are replaced by |map Head|.
\end{example}

This method naturally extends to partial application. To take a more complicated example, where higher-order functions are being used to store information:

\begin{example}
\begin{code}
type Map = String -> Int

new :: Map
new _ = 0

get :: String -> Map -> Int
get key mp = mp key

add :: String -> Int -> Map -> Map
add key val mp s = if s == key then val else get key mp

test = get "foo" (add "bar" 4 (add "baz" 2 new))
\end{code}

\noindent The above code creates a functional map, which uses a higher-order function to store a mapping from |String| to |Int|. The |add| function inserts a new key/value pair into the map. This is transformed with defunctionalization to:

\begin{code}
data Function  =  New
               |  Add3 String Int Function

apply  New                 x = new x
apply  (Add3 y_1 y_2 y_3)  x = add y_1 y_2 y_3 x

new _ = 0

get key mp = apply mp key

add key val mp s = if s == key then val else get key mp

test = get "foo" (Add3 "bar" 4 (Add3 "baz" 2 New))
\end{code}

Here we use the constructor |Add3| to represent the |add| function with three arguments pre-applied. Note that the |Function| data type now serves to store a linked-list of the values with |New| serving a similar role to |[]|, and |Add3| storing one key/value pair along with the remainder of the list.
\end{example}

Defunctionalized code is still type safe, but type checking would require a dependently typed language. The method is complete, removing all higher-order functions, and preserves space behaviour. The disadvantage is that the transformation essentially embeds a mini-interpreter for the original program into the new program. The flow control is complicated by the extra level of indirection.

A natural desire would be to eliminate the higher-order aspects of a program, without introducing any new data structures. However, it is simple to show that this transformation is not possible. Given a program, we can remove all data structures by Church encoding \cite{church_encode}. If we then had a transformation which made the program first-order \textit{without} introducing any data, we would end up with a program without data or closures, which is therefore incapable of storing an unbounded amount of information. Since with higher-order functions we can implement a Turing machine \cite{turing:halting}, and without an unbounded store we cannot, such a transformation cannot exist.

The following methods attempt to remove higher-order functions without introducing any additional data structures, and therefore are not complete. Reynold's method can always be used as a backup, if there are residual higher-order functions.


\section{Argument Specialisation}

The Catch tool presented in \cite{me:catch_tfp} uses specialisation to remove higher-order functions. For each application of a function to unsaturated arguments, a specialised variant is created, and used where applicable. The process follows the same pattern as constructor specialised \cite{spj:specconstr}, but applied to unsaturated expressions rather than known constructors. Examples of common functions whose applications can usually be made first-order include |map|, |filter|, |foldr| and |foldl|. When a function is specialised, the expression passed as the unsaturated argument has all its free variables passed as extra arguments, and is expanded in the specialised version. The specialisation proceeds in three steps:

\begin{enumerate}
\item Find all function calls with unsaturated arguments.
\item Generate specialised variants.
\item Replace calls with the specialised variants.
\end{enumerate}

\begin{example}
\begin{code}
adds x n = map ((+) n) x

map f xs = case  xs of
                 []    -> []
                 y:ys  -> f y : map f ys
\end{code}

\noindent The function |map| is called with the argument |((+) n)|, which is unsaturated. We generate the new function |map_adds| with the rule that |map_adds n x == map ((+) n) x|. We then convert all suitable applications to use |map_adds|.

\begin{code}
adds x n = map_adds n x

map_adds n xs = case  xs of
                      []    -> []
                      y:ys  -> (+) n y : map_adds n ys
\end{code}

An important point is that the transformation has also been made in the recursive call, making the entire fragment first-order.
\end{example}

The method used in \cite{me:catch_tfp} first identifies all invariant arguments, then generates specialised variants. If a specialised variant then invokes further functions with unsaturated arguments, they are not specialised -- the process is not repeated. Specialisation alone is sufficient for many examples, but fails in some cases. Two particular cases where it is insufficient are when unsaturated values are the result of a computation, and when a specialised variant only appears after inlining.

\begin{example}
\begin{code}
id x = x
same = id

main = same 2
\end{code}

Here |same| is a higher-order function, but it is not passed to a function, so is not specialised.
\end{example}

\begin{example}
\begin{code}
apply2 f x = f x
apply f x = apply2 f x

main = apply id 2
\end{code}

Here the only function applied with unsaturated arguments is |apply|, which is called with |id|. We specialise this application to give:

\begin{code}
apply2 f x = f x
apply_id x = apply2 id x

main = apply_id 2
\end{code}

Because we only apply specialisation once, we are still left with the unsaturated |id| function in the |apply2| function.
\end{example}

In the following sections we will see how to reduce the impact of each of the above problems.

\section{Fixed Point of Specialisation}

A natural extension of specialisation is to take the fixed point, eliminating unsaturated expressions in generated functions. Unfortunately, such an algorithm would not terminate.

\begin{example}
\begin{code}
data Wrap a  =  Wrap (Wrap a)
             |  Value a

f x = f (Wrap x)
main = f (Value head)
\end{code}

In the first iteration, this would generate a version of |f| specialised to |Value head|. In the second iteration it would specialise |f| with respect to |Wrap (Value head)|, then in the third with |Wrap (Wrap (Value head))|. We would generate an infinite number of specialisations of |f|.
\end{example}

One simple way to prevent such non-termination is to have a bound on the number of specialisations. Another approach is to use a homeomorphic embedding. All functions relate to some original expression in the Core language, if the expression to be generated was a homeomorphic embedding of an already specialised expression, we can stop.

Using homeomorphic embedding on the previous example, we would generate the following specialised variants of |f (Value head)| and |f (Wrap (Value head))|. Upon attempting to generate the specialised variant |f (Wrap (Wrap (Value head)))| we would abort, with an embedding of |f (Wrap (Value head))|.


\section{Inlining Unsaturated Functions}

The second cause of residual unsaturated expressions is at function and let bindings. If we are willing to ignore the problem of sharing, we can simply inline all let bindings, or all those which bind to unsaturated expressions. We can remove all unsaturated expressions bound at the top-level by inlining them. Returning to the example where specialisation failed:

\begin{example}
\begin{code}
id x = x
same = id

main = same 2
\end{code}

Here |same| is bound to the unsaturated expression |id|, and can be inlined to give:

\begin{code}
id x = x

main = id 2
\end{code}
\end{example}

As with specialisation, the inlining of functions until a fixed point can give rise to non-termination:

\begin{example}
\begin{code}
f = if condition then f else id
\end{code}

The expression bound to |f| will repeatedly grow in size as inlining is applied, and will remain unsaturated. We stop this problem by inlining a function at all application sites, but only once. In this example we would end up with:

\begin{code}
f = if condition then (if condition then f else id) else id
\end{code}

At this stage we have inlined |f| once, so do not inline |f| again.
\end{example}


\section{Results}

Our preferred method for higher-order function removal is to apply specialisation and inlining interleaved. We have tried our method on the nofib suite, and have the following results.
