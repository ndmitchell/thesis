
%include thesis.fmt

\chapter{First-Order Reduction}

The Core language presented in \S\ref{sec:core} is higher-order, but to simplify the analysis in Catch (Chapter \ref{chp:catch}), we work with a first-order language. This chapter gives alternative methods for removing higher-order constructs. For the purposes of this work, we require a transformation that preserves the meaning of a program, but does not necessarily preserve the space behaviour. If such a transformation was done for optimisation purposes, then space behaviour would be critical, but for analysis it is unnecessary.

\section{First-order Core}

\begin{figure}
\begin{code}
prog  =  f |--> vs_ x

expr  =  v                                          {-" \text{  variable} "-}
      |  c xs_                                      {-" \text{  constructor} "-}
      |  f xs_                                      {-" \text{  function} "-}
      |  let v = x in y                             {-" \text{  let binding} "-}
      |  case x of {p_1 -> y_1 ; ... ; p_n -> y_n}  {-" \text{  case expression} "-}

pat   =  c vs_
\end{code}
\caption{First-order Core syntax}
\label{fig:fo_core}
\end{figure}

The first-order Core (FO-Core) language is given in Figure \ref{fig:fo_core}, and is based on the original higher-order Core (HO-Core) given in Figure \ref{fig:core}. The first difference is that a FO-Core program is a mapping of function names to a list of variables and an expression. Compared to the HO-Core, |f| mapping to |vs_ x| would be equivalent to |f| mapping to |\vs_ -> x|. The expression now has vector application for constructors and functions, all of which must be fully saturated. There is no longer an application construct, or a lambda abstraction.

To convert from HO-Core to FO-Core we need to remove some features. Non-saturated constructors can be removed by adding a lambda which fully saturates the constructor. The removal of the lambda expression can be achieved using lambda lifting \cite{lambda_lift}, which replaces lambda's in expressions with top-level lambda abstractions. Applications to let expressions and case expressions can be removed using the case-app and let-app rules from Figure \ref{fig:simplify}.

The only remaining functional values in HO-Core are functions which are not immediately saturated with an application -- i.e. partial application. The only use of a higher-order function is an application to a variable. Functions can be bound to variables at top-level lambda abstractions, case expressions or let expressions. If a function is bound in a let binding then it can be inlined.

There are three methods available which remove higher order functions: Reynolds style defunctionalization, specialisation and super-specialisation. Of these, only Reynolds style is capable of removing all higher-order functions.

\section{Reynolds style defunctionalization}

Reynolds style defunctionalization \cite{reynolds:defunc} is the seminal method for generating a first-order equivalent of a higher-order program.

\begin{example}
\begin{code}
map f x = case  x of
                []      -> []
                (y:ys)  -> f y : map f ys
\end{code}

\noindent Defunctionalization works by creating a data type to represent all values that |f| may take anywhere in the whole program. For instance, it might be:

\ignore\begin{code}
data Function = Head | Tail

apply Head  x = head  x
apply Tail  x = tail  x

map f x = case  x of
                 []      -> []
                 (y:ys)  -> apply f a : map f as
\end{code}

\noindent Now all calls to |map head| are replaced by |map Head|.
\end{example}

This method naturally extends to partial application. To take a more complicated example, where higher-order functions are being used to store information:

\begin{example}
\begin{code}
type Map = String -> Int

new :: Map
new _ = 0

get :: String -> Map -> Int
get key mp = mp key

add :: String -> Int -> Map -> Map
add key val mp s = if s == key then val else get key mp

test = get "foo" (add "bar" 4 (add "baz" 2 new))
\end{code}

\noindent The above code creates a functional map, which uses a higher-order function to store a mapping from |String| to |Int|. The |add| function inserts a new key/value pair into the map. This is transformed with defunctionalization to:

\begin{code}
data Function  =  New
               |  Add3 String Int Function

apply  New                 x = new x
apply  (Add3 y_1 y_2 y_3)  x = add y_1 y_2 y_3 x

new _ = 0

get key mp = apply mp key

add key val mp s = if s == key then val else get key mp

test = get "foo" (Add3 "bar" 4 (Add3 "baz" 2 New))
\end{code}

Here we use the constructor |Add3| to represent the |add| function with three arguments pre-applied. Note that the |Function| data type now serves to store a linked-list of the values with |New| serving a similar role to |[]|, and |Add3| storing one key/value pair along with the remainder of the list.
\end{example}

Defunctionalized code is still type safe, but type checking would require a dependently typed language. The method is complete, removing all higher-order functions, and preserves space behaviour. The disadvantage is that the transformation essentially embeds a mini-interpreter for the original program into the new program. The flow control is complicated by the extra level of indirection.

Reynold's method can always be used as a backup, if other transformation strategies leave residual higher-order functions.

\section{Argument Specialisation}

The Catch tool presented in \cite{me:catch_tfp} uses specialisation to remove higher-order functions. A mutually recursive group of functions can be specialised if one argument is always passed between functions unmodified. Examples of common functions whose applications can be specialised include |map|, |filter|, |foldr| and |foldl|. When a function can be specialised, the expression passed as the invariant argument has all its free variables passed as extra arguments, and is expanded in the specialised version. All recursive calls within the new function are then renamed.

\begin{example}
\begin{code}
adds x n = map ((+) n) x

map f xs = case  xs of
                 []    -> []
                 y:ys  -> f y : map f ys
\end{code}

\noindent is transformed into:

\begin{code}
adds x n = map_adds n x

map_adds n xs = case  xs of
                      []    -> []
                      y:ys  -> (+) n y : map_adds n ys
\end{code}
\end{example}

The method used in \cite{me:catch_tfp} first identifies all invariant arguments, then generates specialised variants. If a specialised variant then invokes further functions with arguments, they are not specialised -- the process is not repeated. Specialisation alone is sufficient for many examples, but it cannot cope with point-free code, and does not deal with many forms of dictionaries.

\subsubsection{Specialisation with Inlining}

The power of specialisation is greatly increased if it is combined with inlining, and applied selectively to higher-order functions.

\begin{figure}
\ignore\begin{code}
data Expr  =  ... -- as in Figure {\ref{fig:core}}
           |  Part   Int FuncName [Expr]
           |  Apply  Expr [Expr]

-- equivalences
Part 0 fn xs == Call fn xs
Apply (Part n fn xs) ys == Part (n - length ys) fn (xs ++ ys)
\end{code}
\caption{Augmented Core syntax.}
\label{fig:core_ho}
\end{figure}

In order to permit a higher-order program to be represented, the Core language is augmented with additional constructs, as shown in Figure \ref{fig:core_ho}. The |Apply| constructor represents an unsaturated function call, or a variable to be used as the function. The |Part| constructor is used to represent unsaturated function calls, leaving the normal |Call| constructor to represent saturated calls. A |Part| construction records how many arguments are needed.

\begin{figure}
\ignore\begin{code}
isHO :: Expr -> Bool
isHO (Part n _ _)    = n > 0
isHO (Make _ xs)     = any isHO xs
isHO (Case on alts)  = any (isHO . snd) alts
isHO _               = False
\end{code}
\caption{Tests for the firstifier.}
\label{fig:isHO}
\end{figure}

The algorithm for removing higher-order functions has two components, specialisation and inlining. We apply the specialise rule until a fixed point is reached, then apply the inline rule once. We repeat these two steps until a fixed point is reached. Given an appropriate |fix| function, |firstify| can be implemented as:

\ignore\begin{code}
firstify :: Program -> Program
firstify = fix (inline . fix specialise)
\end{code}

\paragraph{The |inline| stage} inlines each |Call| for which the body passes the |isHO| test, defined in Figure \ref{fig:isHO}. If this process causes a function to no longer be called from the root of the program, then the function is removed after inlining.

\paragraph{The |specialise| stage} takes every expression of the form |Call fn xs| where \ignore|any isHO xs|, and generates a specialised version of the function |fn| with all functional arguments in |xs| frozen in, and all others passed normally.

In rare circumstances a program may have an infinite number of specialisations. If necessary we revert to Reynolds style defunctionalization.

The combination of specialisation and inlining is powerful. We have encountered few examples where it fails -- mainly artificial tests created specifically to break the approach! In the definition of a higher-order function either the entire body is an application of the functional argument (in which case it will be inlined), or it must occur as the argument to a function (in which case it is specialised). There are only two places left for functional arguments to be used: (1) As the subject of a \ignore|case| expression. But this situation is impossible as all \ignore|case| expressions must choose over a data value. (2) Inside an |Apply| with another functional argument variable as the function. This situation is rare due to the removal of other functional arguments.
