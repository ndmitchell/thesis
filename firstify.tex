
%include thesis.fmt

\chapter{First-Order Reduction}

\section{Converting Haskell to a First-order Core}
\label{sec:transform}



\subsection{First-Order Haskell}

The analysis presented in \S\ref{sec:manipulate} operates on a first-order language. In order to analyse full Haskell, we transform Haskell to a first-order language. We briefly consider three alternative methods.

\subsubsection{Reynolds style defunctionalization}

Reynolds style defunctionalization \citep{reynolds:defunc} is the seminal method for generating a first-order equivalent of a higher-order program.

\begin{example}
\begin{code}
map fn x = case  x of
                 []      -> []
                 (a:as)  -> fn a : map fn as
\end{code}

\noindent Defunctionalization works by creating a data type to represent all values that |fn| may take anywhere in the whole program. For instance, it might be:

\ignore\begin{code}
data Functions = Head | Tail

apply Head  x = head  x
apply Tail  x = tail  x

map fn x = case  x of
                 []      -> []
                 (a:as)  -> apply fn a : map fn as
\end{code}

\noindent Now all calls to |map head| are replaced by \ignore|map Head|.
\end{example}

Defunctionalized code is still type safe, but type checking would require a dependently typed language. This presents no problem for \catch{}, which does not use type information. The unacceptable aspect is the creation of an |apply| function, whose meaning is excessively general, introducing a bottleneck through which various properties must be proven. Asking questions such as \textit{``Is the result of |apply| an empty-list?''}, requires a lot of computation.

\catch{} only uses Reynolds style defunctionalization if all other methods fail.


\subsubsection{Specialisation}

\oldtool{} uses a different technique to remove higher-order functions: specialisation. A mutually recursive group of functions can be specialised if one argument is always passed between functions unmodified. Examples of common functions whose applications can be specialised include |map|, |filter|, |foldr| and |foldl|. When a function can be specialised, the expression passed as the invariant argument has all its free variables passed as extra arguments, and is expanded in the specialised version. All recursive calls within the new function are then renamed.

\begin{example}
\begin{code}
adds x n = map ((+) n) x
map fn xs =  case  xs of
             []      -> []
             (a:as)  -> fn a : map fn as
\end{code}

\noindent is transformed into:

\begin{code}
adds x n = map_adds n x
map_adds n xs =  case  xs of
                 []      -> []
                 (a:as)  -> (+) n a : map_adds n as
\end{code}\codeexample
\end{example}

Specialisation alone is sufficient for many examples, but it cannot cope with point-free code, and does not deal with many forms of dictionaries.

\subsubsection{Specialisation with Inlining}

The power of specialisation is greatly increased if it is combined with inlining, and applied selectively to higher-order functions.

\begin{figure}
\ignore\begin{code}
data Expr  =  ... -- as in Figure {\ref{fig:core}}
           |  Part   Int FuncName [Expr]
           |  Apply  Expr [Expr]

-- equivalences
Part 0 fn xs == Call fn xs
Apply (Part n fn xs) ys == Part (n - length ys) fn (xs ++ ys)
\end{code}
\caption{Augmented Core syntax.}
\label{fig:core_ho}
\end{figure}

In order to permit a higher-order program to be represented, the Core language is augmented with additional constructs, as shown in Figure \ref{fig:core_ho}. The |Apply| constructor represents an unsaturated function call, or a variable to be used as the function. The |Part| constructor is used to represent unsaturated function calls, leaving the normal |Call| constructor to represent saturated calls. A |Part| construction records how many arguments are needed.

\begin{figure}
\ignore\begin{code}
isHO :: Expr -> Bool
isHO (Part n _ _)    = n > 0
isHO (Make _ xs)     = any isHO xs
isHO (Case on alts)  = any (isHO . snd) alts
isHO _               = False
\end{code}
\caption{Tests for the firstifier.}
\label{fig:isHO}
\end{figure}

The algorithm for removing higher-order functions has two components, specialisation and inlining. We apply the specialise rule until a fixed point is reached, then apply the inline rule once. We repeat these two steps until a fixed point is reached. Given an appropriate |fix| function, |firstify| can be implemented as:

\ignore\begin{code}
firstify :: Program -> Program
firstify = fix (inline . fix specialise)
\end{code}

\paragraph{The |inline| stage} inlines each |Call| for which the body passes the |isHO| test, defined in Figure \ref{fig:isHO}. If this process causes a function to no longer be called from the root of the program, then the function is removed after inlining.

\paragraph{The |specialise| stage} takes every expression of the form |Call fn xs| where \ignore|any isHO xs|, and generates a specialised version of the function |fn| with all functional arguments in |xs| frozen in, and all others passed normally.

In rare circumstances a program may have an infinite number of specialisations. If necessary we revert to Reynolds style defunctionalization.

The combination of specialisation and inlining is powerful. We have encountered few examples where it fails -- mainly artificial tests created specifically to break the approach! In the definition of a higher-order function either the entire body is an application of the functional argument (in which case it will be inlined), or it must occur as the argument to a function (in which case it is specialised). There are only two places left for functional arguments to be used: (1) As the subject of a \ignore|case| expression. But this situation is impossible as all \ignore|case| expressions must choose over a data value. (2) Inside an |Apply| with another functional argument variable as the function. This situation is rare due to the removal of other functional arguments.
