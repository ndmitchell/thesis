
%include thesis.fmt

\chapter{First-Order Reduction}

The Core language presented in \S\ref{sec:core} is higher-order, but to simplify the analysis in Catch (Chapter \ref{chp:catch}), we work with a first-order language. This chapter gives alternative methods for removing higher-order constructs. For the purposes of this work, we require a transformation that preserves the meaning of a program, but does not necessarily preserve the space behaviour. If such a transformation was done for optimisation purposes, then space behaviour would be critical, but for analysis it is unnecessary.

\section{First-order Core}

\begin{figure}
\begin{code}
prog  =  f |--> vs_ x

expr  =  v                                          {-" \text{  variable} "-}
      |  c xs_                                      {-" \text{  constructor} "-}
      |  f xs_                                      {-" \text{  function} "-}
      |  let v = x in y                             {-" \text{  let binding} "-}
      |  case x of {p_1 -> y_1 ; ... ; p_n -> y_n}  {-" \text{  case expression} "-}
      |  v @ xs_                                    {-" \text{  variable application} "-}

pat   =  c vs_
\end{code}
\caption{First-order Core syntax}
\label{fig:fo_core}
\end{figure}

The first-order Core (FO-Core) language is given in Figure \ref{fig:fo_core}, and is based on the original higher-order Core (HO-Core) given in Figure \ref{fig:core}. The first difference is that a FO-Core program is a mapping of function names to a list of variables and an expression. Compared to the HO-Core, |f| mapping to |vs_ x| would be equivalent to |f| mapping to |\vs_ -> x|. The expression now has vector application for constructors and functions, all of which must be fully saturated. There is no longer a general application construct, or a lambda abstraction.

There is one new construct, variable application, written |v @ xs_| which applies the expressions |xs_| to the higher-order function bound to variable |v|. If a program has any |@| expressions within it, then it is no longer first-order. By permitting |@| expressions to appear, and relaxing the requirement that |f xs_| is saturated, we obtain a higher-order language which is suitable for transforming to first-order.

To convert from HO-Core to FO-Core we need to remove some features. Non-saturated constructors can be removed by adding a lambda which fully saturates the constructor. The removal of the lambda expression can be achieved using lambda lifting \cite{lambda_lift}, which replaces lambda's in expressions with top-level lambda abstractions. Applications to let expressions and case expressions can be removed using the case-app and let-app rules from Figure \ref{fig:simplify}.

The only remaining functional values in HO-Core are functions which are not immediately saturated with an application -- i.e. partial application. The only use of a higher-order function is an application to a variable. The partial application can be represented in FO-Core, and the application to a variable can be represented with an |@| expression.

\begin{figure}
\begin{code}
unsaturated :: Expr -> Bool
unsaturated v = False
unsaturated (c xs_) = any unsaturated xs_
unsaturated (f xs_) = arity f /= length xs_
unsaturated (let v = x in y) = unsaturated (y[v/x])
unsaturated (case x of alts_) = any f alts_
    where f (c vs_ -> y) = unsaturated y
unsaturated (v @ xs_) = False
\end{code}
\caption{Definition of which expressions are |unsaturated|.}
\label{fig:unsaturated}
\end{figure}

An expression is unsaturated if it evaluates to a lambda expression. One way of checking this property is using the type system. An alternative approximation is using the |unsaturated| function in Figure \ref{fig:unsaturated}, which we use.

There are three methods available which remove higher order functions: Reynolds style defunctionalization, specialisation and super-specialisation. Of these, only Reynolds style is capable of removing all higher-order functions.

\section{Reynolds style defunctionalization}

Reynolds style defunctionalization \cite{reynolds:defunc} is the seminal method for generating a first-order equivalent of a higher-order program.

\begin{example}
\begin{code}
map f x = case  x of
                []      -> []
                (y:ys)  -> f y : map f ys
\end{code}

\noindent Defunctionalization works by creating a data type to represent all values that |f| may take anywhere in the whole program. For instance, it might be:

\ignore\begin{code}
data Function = Head | Tail

apply Head  x = head  x
apply Tail  x = tail  x

map f x = case  x of
                []    -> []
                y:ys  -> apply f a : map f as
\end{code}

\noindent Now all calls to |map head| are replaced by |map Head|.
\end{example}

This method naturally extends to partial application. To take a more complicated example, where higher-order functions are being used to store information:

\begin{example}
\begin{code}
type Map = String -> Int

new :: Map
new _ = 0

get :: String -> Map -> Int
get key mp = mp key

add :: String -> Int -> Map -> Map
add key val mp s = if s == key then val else get key mp

test = get "foo" (add "bar" 4 (add "baz" 2 new))
\end{code}

\noindent The above code creates a functional map, which uses a higher-order function to store a mapping from |String| to |Int|. The |add| function inserts a new key/value pair into the map. This is transformed with defunctionalization to:

\begin{code}
data Function  =  New
               |  Add3 String Int Function

apply  New                 x = new x
apply  (Add3 y_1 y_2 y_3)  x = add y_1 y_2 y_3 x

new _ = 0

get key mp = apply mp key

add key val mp s = if s == key then val else get key mp

test = get "foo" (Add3 "bar" 4 (Add3 "baz" 2 New))
\end{code}

Here we use the constructor |Add3| to represent the |add| function with three arguments pre-applied. Note that the |Function| data type now serves to store a linked-list of the values with |New| serving a similar role to |[]|, and |Add3| storing one key/value pair along with the remainder of the list.
\end{example}

Defunctionalized code is still type safe, but type checking would require a dependently typed language. The method is complete, removing all higher-order functions, and preserves space behaviour. The disadvantage is that the transformation essentially embeds a mini-interpreter for the original program into the new program. The flow control is complicated by the extra level of indirection.

A natural desire would be to eliminate the higher-order aspects of a program, without introducing any new data structures. However, it is simple to show that this transformation is not possible. Given a program, we can remove all data structures by Church encoding \cite{church_encode}. If we then had a transformation which made the program first-order \textit{without} introducing any data, we would end up with a program without data or closures, which is therefore incapable of storing an unbounded amount of information. Since with higher-order functions we can implement a Turing machine \cite{turing:halting}, and without an unbounded store we cannot, such a transformation cannot exist.

The following methods attempt to remove higher-order functions without introducing any additional data structures, and therefore are not complete. Reynold's method can always be used as a backup, if there are residual higher-order functions.


\section{Argument Specialisation}

The Catch tool presented in \cite{me:catch_tfp} uses specialisation to remove higher-order functions. For each application of a function to unsaturated arguments, a specialised variant is created, and used where applicable. The process follows the same pattern as constructor specialised \cite{spj:specconstr}, but applied to unsaturated expressions rather than known constructors. Examples of common functions whose applications can usually be made first-order include |map|, |filter|, |foldr| and |foldl|. When a function is specialised, the expression passed as the unsaturated argument has all its free variables passed as extra arguments, and is expanded in the specialised version. The specialisation proceeds in three steps:

\begin{enumerate}
\item Find all function calls with unsaturated arguments.
\item Generate specialised variants.
\item Replace calls with the specialised variants.
\end{enumerate}

\begin{example}
\begin{code}
adds x n = map ((+) n) x

map f xs = case  xs of
                 []    -> []
                 y:ys  -> f y : map f ys
\end{code}

\noindent The function |map| is called with the argument |((+) n)|, which is unsaturated. We generate the new function |map_adds| with the rule that |map_adds n x == map ((+) n) x|. We then convert all suitable applications to use |map_adds|.

\begin{code}
adds x n = map_adds n x

map_adds n xs = case  xs of
                      []    -> []
                      y:ys  -> (+) n y : map_adds n ys
\end{code}

An important point is that the transformation has also been made in the recursive call, making the entire fragment first-order.
\end{example}

The method used in \cite{me:catch_tfp} first identifies all invariant arguments, then generates specialised variants. If a specialised variant then invokes further functions with unsaturated arguments, they are not specialised -- the process is not repeated. Specialisation alone is sufficient for many examples, but fails in some cases. Two particular cases where it is insufficient are when unsaturated values are the result of a computation, and when a specialised variant only appears after inlining.

\begin{example}
\begin{code}
id x = x
same = id

main = same 2
\end{code}

Here |same| is a higher-order function, but it is not passed to a function, so is not specialised.
\end{example}

\begin{example}
\begin{code}
apply2 f x = f x
apply f x = apply2 f x

main = apply id 2
\end{code}

Here the only function applied with unsaturated arguments is |apply|, which is called with |id|. We specialise this application to give:

\begin{code}
apply2 f x = f x
apply_id x = apply2 id x

main = apply_id 2
\end{code}

Because we only apply specialisation once, we are still left with the unsaturated |id| function in the |apply2| function.
\end{example}

In the following sections we will see how to reduce the impact of each of the above problems.

\section{Fixed Point of Specialisation}

A natural extension of specialisation is to take the fixed point, eliminating unsaturated expressions in generated functions. Unfortunately, such an algorithm would not terminate.

\begin{example}
\begin{code}
data Wrap a  =  Wrap (Wrap a)
             |  Value a

f x = f (Wrap x)
main = f (Value head)
\end{code}

In the first iteration, this would generate a version of |f| specialised to |Value head|. In the second iteration it would specialise |f| with respect to |Wrap (Value head)|, then in the third with |Wrap (Wrap (Value head))|. We would generate an infinite number of specialisations of |f|.
\end{example}

One simple way to prevent such non-termination is to have a bound on the number of specialisations. Another approach is to use a homeomorphic embedding. All functions relate to some original expression in the Core language, if the expression to be generated was a homeomorphic embedding of an already specialised expression, we can stop.

Using homeomorphic embedding on the previous example, we would generate the following specialised variants of |f (Value head)| and |f (Wrap (Value head))|. Upon attempting to generate the specialised variant |f (Wrap (Wrap (Value head)))| we would abort, with an embedding of |f (Wrap (Value head))|.


\section{Inlining Unsaturated Functions}

The second cause of residual unsaturated expressions is at function and let bindings. If we are willing to ignore the problem of sharing, we can simply inline all let bindings, or all those which bind to unsaturated expressions. We can remove all unsaturated expressions bound at the top-level by inlining them. Returning to the example where specialisation failed:

\begin{example}
\begin{code}
id x = x
same = id

main = same 2
\end{code}

Here |same| is bound to the unsaturated expression |id|, and can be inlined to give:

\begin{code}
id x = x

main = id 2
\end{code}
\end{example}

As with specialisation, the inlining of functions until a fixed point can give rise to non-termination:

\begin{example}
\begin{code}
f = if condition then f else id
\end{code}

The expression bound to |f| will repeatedly grow in size as inlining is applied, and will remain unsaturated. We stop this problem by inlining a function at all application sites, but only once. In this example we would end up with:

\begin{code}
f = if condition then (if condition then f else id) else id
\end{code}

At this stage we have inlined |f| once, so do not inline |f| again.
\end{example}


\section{Results}

Our preferred method for higher-order function removal is to apply specialisation and inlining interleaved. We have tried our method on the nofib suite, and have the following results.


