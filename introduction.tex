%include paper.fmt

\chapter{Introduction}
\label{chp:introduction}

This thesis focuses on the field of functional programming, particularly the Haskell programming language \cite{haskell}. Haskell is both lazy and pure, which allows greater freedom when manipulating and reasoning about Haskell programs. In this thesis, we describe two transformations and one analysis method for Haskell programs. We have implemented all our techniques in Haskell. While we have made use of Haskell, much of our work should be applicable to any functional language.

In this chapter, we first discuss the motivation underlying the problems we have chosen, by explaining how the problems are intertwined. Next we provide details of where to obtain implementations of the algorithms associated with this thesis, followed by a description of each of the following chapters.


\section{Motivation and Objectives}

Haskell is a strongly typed language, ensuring that a large class of errors are caught at compile time. The strong typing has lead people to state that ``if a Haskell program type checks, it usually works''. However, despite all the guarantees that the type system gives, programs may still fail. Our goal was to write a tool to ensure certain types of failure could not occur.

A Haskell program may fail in one of three ways:

\begin{description}
\item[Performs the wrong computation] Detecting this failure requires specific annotations from the programmer to express their intent. In order to gain the greatest audience possible, we decided to not require any annotations on a program, so ignored this issue.
\item[Non-termination] The issue of non-termination has been investigated extensively -- one particularly impressive tool already exists in the AProVE framework \cite{aprove_haskell}.
\item[Calling |error|] The final issue relates to calling |error|, commonly as the result of a pattern-match with no matching clause. This issue has not received as much attention, with suggestions that programmers only use exhaustive patterns \cite{turner:total}, or local analysis to decide which patterns are exhaustive \cite{maranget:pattern_warnings}. The problem of calling |error| is a practical one, with such failures being a common occurrence when developing a Haskell program.
\end{description}

We first developed a tool to check for calls to |error|, named Catch, for a first-order language. We then attempted to extend the checker to a higher-order language, but failed. A higher-order program hides the flow control within a program, and our particular method required large numbers of constraints to be associated with functional values in complex ways. As a result we looked at an alternative, making a higher-order program first-order. We started by taking existing transformations, particularly specialisation, and combining them into a complete defunctionalisation method, which we called Firstify.

After making a program first-order, it tends to execute faster than before. As we explored this side-effect of the defunctionalisation, we were drawn in new directions. The idea was that you could obtain a defunctionalisation method by taking a very powerful program optimiser, and restricting it. We chose to start with the work on supercompilation, which already bore some similarities to our defunctionalisation  method. Unfortunately, this hope turned out to be ill-founded -- supercompilation is not a suitable method for defunctionalisation. However, we were able to push our original defunctionalisation method, using techniques inspired by supercompilation, into a usable transformation. The defunctionalisation method is designed as a transformation before analysis, primarily for Catch, but can be used independently.

Our work on supercompilation aims to allow Haskell programs to be written in a high-level style, yet perform competitively. Often, to obtain high performance, Haskell programmers will be forced to make use of low-level features such as unboxed types \cite{spj:unboxing}, provide additional annotations such as rewrite rules \cite{spj:rules} and express programs in an unnatural style, such as using |foldr| to obtain deforestation \cite{gill:shortcut_deforestation}. Our supercompiler is called Supero, and can optimise Haskell programs, providing substantial speed-ups in some cases. Our hope is to remove the need for programmers to manually optimise at the local level.

Our final contribution is the Uniplate library. The expression type of the Core language we work with has over ten constructors. Most of these constructors contain embedded subexpressions. For most operations, we wish to have value-specific behaviour for a handful of constructors, and a default operation for all the others. We started developing a small library of useful functions to deal with this complexity, and gradually abstracted the ideas. After refinement, the Uniplate library emerged. The Uniplate library stands apart from the rest of the thesis in that it does not work on a core functional language, but is instead a general purpose library. However, the Uniplate techniques have been invaluable in implementing the other transformations.


\section{Implementations}

We have implemented all the ideas presented in this thesis, and include sample code in the appropriate chapters. Most of our implementations make use of a monadic framework to deal with issues such as obtaining unique free variables and tracking termination constraints. But to simplify the presentation, we ignore these issues -- they are mostly tedious engineering concerns, and do not effect the underlying algorithms.

All the code is available from the authors homepage\footnote{\url{http://www.cs.york.ac.uk/~ndm/}}. Additionally, we have released the folllowing packages on the Hackage website\footnote{\url{http://hackage.haskell.org/}}:

\begin{description}
\item[Homeomorphic] This is a library for testing homeomorphic embedding, used to ensure termination, as described in \S\ref{secB:homeomorphic}.
\item[Uniplate] This is the library described in Chapter \ref{chp:uniplate}.
\item[Yhc.Core] This is a library providing the data type for Yhc's Core language. It requires Uniplate to implement some of the functions.
\item[Supero] This is the program described in Chapter \ref{chp:supero}. It requires Yhc.Core as the Core language to operate on, Homeomorphic to ensure termination and Uniplate for various transformations.
\item[Firstify] This is the library described in Chapter \ref{chp:firstify}. Like Supero, this library requires Yhc.Core, Homeomorphic and Uniplate.
\item[Catch] This is the program described in Chapter \ref{chp:catch}. This library requires Firstify and all its dependencies, to convert the initial higher-order program to a first-order equivalent.
\end{description}

\section{Chapter Outline}

The Background chapter (\ref{chp:background}) describes a common Core language which is used in the subsequent chapters. It also describes the homeomorphic embedding relation, used to ensure termination in a number of transformations.

The Boilerplate Removal chapter (\ref{chp:uniplate}) describes the Uniplate library. In particular, it describes the interface to the library -- both the traversal functions and the information a data type must provide. It also compares the Uniplate library to the Scrap Your Boilerplate (SYB) library \cite{lammel:syb} and the Compos library \cite{bringert:compos} -- both in terms of speed and conciseness.

The Supercompilation chapter (\ref{chp:supero}) describes the design and implementation of the Supero tool. The method includes techniques for detailing with let bindings, and a new method for generalisation. Results are presented comparing Supero to C, and to the Glasgow Haskell Compiler (GHC) \cite{ghc}.

The Defunctionalisation chapter (\ref{chp:firstify}) describes how to combine several existing transformations to produce a defunctionalisation method. The main focus is how to restrict the existing methods to ensure they terminate and cooperate to obtain a program with few residual functional values.

The Pattern Match Analysis chapter (\ref{chp:catch}) describes the implementation of the Catch tool. It presents a mechanism for reasoning about programs using a constraint language, along with two alternative constraint languages. The Catch tool is tested on a number of benchmark programs, and for several larger programs.

The Conclusions and Relation Work chapter (\ref{chp:conclusions}) gives directions for future work, and makes concluding remarks.

