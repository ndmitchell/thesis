%include thesis.fmt
%include catch.fmt

%format /# = "/"

\hsdef{\begin{comment}
k,f,c,v,i,on,xs_i,x,ys_i
vs,xs,y,as,ys,cs
\end{comment}}
\begin{comment}
\begin{code}
import Prelude hiding (($),(/))
import Data.List

infixr 1  $
infixr 0  ==>
class Implies a where (==>) :: a -> a -> Bool
($) :: (a -> b) -> a -> b

instance Implies Bool
instance Implies (Prop a)

type FuncName = String
type CtorName = String
type VarName = String

freeVars :: Expr -> [String]
body   :: FuncName  -> Expr
args   :: FuncName  -> [VarName]
var    :: VarName   -> Maybe (Expr, Selector)
ctors  :: CtorName  -> [CtorName]
type Selector  =  (CtorName, Int)

precond   :: FuncName -> Prop (Sat VarName)
prePost   :: FuncName -> Constraint -> Prop (Sat VarName)
pre ::  Expr -> Prop (Sat Expr)
reduce    :: Prop (Sat Expr) -> Prop (Sat VarName)
red :: Expr -> Constraint -> Prop (Sat VarName)
substP :: Eq alpha => [(alpha,beta)] -> Prop (Sat alpha) -> Prop (Sat beta)

data Sat alpha = Sat alpha Constraint
instance Eq a => Eq (Sat a)

(-<)  :: alpha -> [CtorName] -> Prop (Sat alpha)
(|>)  :: Selector -> Constraint -> Constraint
(<|)  :: CtorName -> Constraint -> Prop (Sat Int)

data Prop alpha
instance Eq a => Eq (Prop a)

propAnd, propOr           :: Prop alpha -> Prop alpha -> Prop alpha
propAnds, propOrs         :: [Prop alpha] -> Prop alpha
propMap                   :: (alpha -> Prop beta) -> Prop alpha -> Prop beta
propTrue, propFalse       :: Prop alpha
propBool                  :: Bool -> Prop alpha
propLit                   :: alpha -> Prop alpha

data Constraint = Constraint

class Subst a b c | c -> b, a -> b, c -> a where (/) :: a -> b -> c
instance Subst Expr ([VarName], [Expr]) Expr
instance Subst (Prop (Sat Int)) ([Int], [Val]) (Prop (Sat Val))
instance Subst (Prop (Sat VarName)) ([VarName], [Expr]) (Prop (Sat Expr))

(/#) :: Prop (Sat Expr) -> ([VarName], [Expr]) -> Prop (Sat Expr)

instance Eq Val
instance Eq Expr

alt :: Alt -> Prop (Sat a)
\end{code}
\end{comment}


\section{Argument for Correctness}
\label{secC:correct}

\newcommand{\lemma}[1]{(\textit{#1})}
\newcommand{\theorem}[2]{#2 \hspace{5mm} \lemma{#1} \\}
\newcommand{\proof}[2][]{\paragraph{\lemma{#2} \textsf{#1}}}

The algorithm is correct if given a function application whose arguments meet the precondition, it will not call |error|. The proof is structured as an evaluator with an explicit |Bottom| within it -- if this case is encountered the program will crash at runtime. We reason about the evaluator to show satisfying a precondition ensures that |Bottom| will not be reached. This corresponds to a proof of Figures \ref{figC:property_fixp}, \ref{figC:precondition}, \ref{figC:precond_fixp} and \ref{figC:prop}.

To perform the proof, we require various laws about the |-<|, | ||>| and |<||| operators, which we then show hold for each of the three constraint systems.

\subsection{Evaluator}

First we introduce functions and definitions which will be required later.

\begin{code}
data Val  =  Val CtorName [Val]
          |  Bottom

data Expr  =  Make CtorName [Expr]
           |  Call FuncName [Expr]
           |  Var  VarName
           |  Case Expr [Alt]

data Alt = Alt CtorName [VarName] Expr

eval :: Expr -> Val
eval (Make c xs   ) = Val c (map eval xs)
eval (Call f xs)  | f == "error" = Bottom
                  | otherwise = eval $ body f / (args f, xs)
eval (Case x as   ) = case eval x of
    Val c xs -> eval $ head [y / (vs, map uneval xs) | Alt c' vs y <- as, c == c']
    Bottom -> Bottom

uneval :: Val -> Expr
uneval (Val c xs)  = Make c (map uneval xs)
uneval Bottom      = Call "error" []
\end{code}

We make use of |(/)|, which we have redefined as a substitution operator -- we write |x / (vs,ys)| to denote replacing the free variables |vs| in |x| with |ys|. We use |(/)| instead of |substP| in the proofs. There is no |eval| alternative for |Var|, as an expression at evaluation will not have any free variables, as substitution will remove them. We can assume the argument to |eval| has no free variables. The free variables of a function are its arguments.

We also make use of a number of auxiliaries throughout the proof:

\begin{code}
isBottom :: Val -> Bool
isBottom Bottom = True
isBottom (Val c xs) = any isBottom xs

valCtor :: Val -> Maybe CtorName
valCtor (Val c xs) = Just c
valCtor Bottom = Nothing

propTaut :: (alpha -> Bool) -> Prop alpha -> Bool
propTaut f x = (propTrue :: Prop ()) == propMap (propBool . f) x

satE' :: Prop (Sat Expr) -> Bool
satE' = propTaut satE

satE :: Sat Expr -> Bool
satE (Sat x k) = sat (eval x) k

satV' :: Prop (Sat Val) -> Bool
satV' = propTaut satV

satV :: Sat Val -> Bool
satV (Sat v k) = sat v k

sat :: Val -> Constraint -> Bool
\end{code}

Of these functions, |sat| is primitive and different for each constraint language. All the expressions given to |satE| must have no free variables, as |eval| cannot deal with them.

\subsection{Theorems}

We wish to prove:

\theorem{pre/eval}
{|satE' $ pre x ==> not $ isBottom $ eval x|}

In particular this requires the following theorems about the constraint language:

\theorem{sat/|-<|}
{|satV' $ x -< cs ==> maybe True (`elem` cs) (valCtor x)|}

\theorem{sat/| ||> |}
{|sat (Val c xs) ((c,i) ||> k) ==> sat (xs !! i) k|}

\theorem{sat/| <|| |}
{|satV' $ (c <|| k) / ([1..],xs) ==> sat (Val c xs) k|}

We will also need the following general theorems:

\theorem{precond/error}
{|precond "error" == propFalse|}

\theorem{precond}
{|precond f ==> reduce $ pre $ body f|}

\theorem{reduce}
{|satE' $ reduce x / (vs,xs) ==> satE' $ x / (vs, xs)|}

%\theorem{sat/subst}
%{|sat (pre x / (freeVars x, ys)) && all (sat . pre) ys ==> sat $ pre $ x / (freeVars x, ys)|}

\theorem{pre/uneval}
{|not $ isBottom x ==> satE' $ pre $ uneval x|}

\subsubsection{The Proof}

We prove each lemma in turn.

\proof{pre/eval}

By induction. We do not need to consider |Var| as |eval| cannot be called on expressions with free variables.

\proof[|Make|:]{pre/eval}

The initial definition is:

\begin{code}
eval (Make c xs) = Val c (map eval xs)
\end{code}

This does not produce |Bottom| if all recursive calls to |eval| are on values which satisfy |pre|. We can write this as:

\h{exprlist}\begin{code}
satE' $ pre $ Make c xs  ==> all (satE' . pre) xs
    -- inline |pre|
satE' $ propAnds $ map pre xs ==> all (satE' . pre) xs
    -- inline |satE'|
and $ map satE' $ map pre xs  ==> all (satE' . pre) xs
    -- |map f . map g == map (f . g)|
and $ map (satE' . pre) xs ==> all (satE' . pre) xs
    -- |and . map f == all f|
all (satE' . pre) xs ==> all (satE' . pre) xs
    -- equal
True
\end{code}

\proof[|Call|:]{pre/eval}

The initial definition is:

\begin{code}
eval (Call f xs)  | f == "error" = Bottom
                   | otherwise = eval $ body f / (args f, xs)
\end{code}

There are two ways to get |Bottom| from this fragment. The first is the explicit |Bottom|, and the second is the recursive call to |eval|. The first |Bottom| is avoided under the condition:

\h{exprlist}\begin{code}
satE' $ pre $ Call f xs ==> f /= "error"
    -- inline |pre|
satE' $ (precond f / (args f, xs)) `propAnd` propAnds (map pre xs) ==> f /= "error"
    -- inline |satE'|
satE' (precond f / (args f, xs)) && all (satE' . pre) xs ==> f /= "error"
    -- weaken implication
satE' (precond f / (args f, xs)) ==> f /= "error"
\end{code}


We can now perform case analysis on |f|, assuming it either is, or is not, equal to |"error"|.

\h{exprlist}\begin{code}
satE' (precond f / (args f, xs)) ==> f /= "error"
    -- assume |f /= "error"|
satE' (precond f / (args f, xs)) ==> True
    -- implication
True
\end{code}

\h{exprlist}\begin{code}
satE' (precond f / (args f, xs)) ==> f /= "error"
    -- assume |f == "error"|
satE' (precond f / (args f, xs)) ==> False
    -- implication
not $ satE' (precond "error" / (args f, xs))
    -- \lemma{precond/error}
not $ satE' $ (propFalse / (args f, xs))
    -- inline |(/)|
not $ satE' propFalse
    -- inline |satE'|
not $ False
    -- inline |not|
True
\end{code}

This leaves us with the call to |eval|, namely:

\h{exprlist}\begin{code}
satE' $ pre $ Call f xs ==> satE' $ pre $ body f / (args f, xs)
    -- inline pre on LHS
satE' $ (precond f / (args f, xs)) `propAnd` propAnds (map pre xs) ==> satE' $ pre $ body f / (args f, xs)
    -- inline |satE'|
satE' (precond f / (args f, xs)) && all (satE' . pre) xs ==> satE' $ pre $ body f / (args f, xs)
    -- \lemma{precond}
satE' ((reduce $ pre $ body f) / (args f, xs)) && all (satE' . pre) xs ==> satE' $ pre $ body f / (args f, xs)
    -- \lemma{reduce}
satE' (pre (body f) /# (args f, xs)) && all (satE' . pre) xs ==> satE' $ pre $ body f / (args f, xs)
    -- \lemma{pre/subst}
True
\end{code}

\proof[|Case|:]{pre/eval}

\begin{code}
eval (Case x as  ) = case eval x of
    Val c xs -> eval $ head [y / (vs, map uneval xs) | Alt c' vs y <- as, c == c']
    Bottom -> Bottom
\end{code}

This equation may generate |Bottom| in two ways -- either the explicit |Bottom| may be taken, or the nested |eval| may be taken. In both cases, if we can prove the expression passed to |eval| satisfies its precondition, then we can eliminate the possibility of |Bottom|.

We first prove that the explicit |Bottom| is not reached, assuming the initial expression does not violate the precondition check.

\h{exprlist}\begin{code}
satE' $ pre $ Case x as ==> satE' $ pre x
    -- inline |pre|
satE' $ pre x `propAnd` propAnds (map alt as) ==> satE' $ pre x
    -- inline |satE'|
satE' (pre x) && satE' (propAnds $ map alt as) ==> satE' $ pre x
    -- weaken implication
satE' $ pre x ==> satE' $ pre x
    -- equal
True
\end{code}

We now need to ensure that the other call to |eval| meets its precondition:

%if 0

\h{exprlist}\begin{code}
sat (pre (Case x as)) && (eval x == Val c xs) ==> sat $ pre $ y / (vs, map uneval xs)
\end{code}

First we can work on the RHS only:

\h{exprlist}\begin{code}
sat $ pre $ y / (vs, map uneval xs)
    -- \lemma{pre/subst}
sat (pre y / (vs, map uneval xs)) && all (sat . pre) (map uneval xs)
    -- |all f . map g == all (f . g)|
sat (pre y / (vs, map uneval xs)) && all (sat . pre . uneval) xs
    -- \lemma{pre/uneval}
sat (pre y / (vs, map uneval xs)) && all (sat . const propTrue) xs
    -- inline |sat|
sat (pre y / (vs, map uneval xs)) && all (const True) xs
    -- |all (const True) xs == True|
sat (pre y / (vs, map uneval xs))
\end{code}

We can now return to the whole thing, assuming that the constructor is the first to be chosen. We can reorder the alternatives because they have no order and are processed in a map in the code. We can assume that |x| matches \ignore|Val c _| because that branch has been picked.

\h{exprlist}\begin{code}
sat $ pre $ Case x (Alt c vs y : as) ==> sat $ pre y
    -- inline |pre|
sat $ pre x `propAnd` propAnds (map alt (Alt c vs y : as)) ==> sat $ pre y
    -- inline |sat|
sat (pre x) && all (sat . alt) (Alt c vs y : as) ==> sat $ pre y
    -- inline |all|
sat (pre x) && sat (alt (Alt c vs y)) && all (sat . alt) as ==> sat $ pre y
    -- weaken the implication
sat $ alt $ Alt c vs y ==> sat $ pre y
    -- inline |alt|
sat $ x -< (ctors c \\ [c]) `propOr` pre y ==> sat $ pre y
    -- inline |sat|
sat (x -< (ctors c \\ [c])) || sat (pre y) ==> sat $ pre y
    -- \lemma{sat/|-<|}
ctor x `elem` (ctors c \\ [c]) || sat (pre y) ==> sat $ pre y
    -- |ctor x == c|
c `elem` (ctors c \\ [c]) || sat (pre y) ==> sat $ pre y
    -- \lemma{elem/diff}
False || sat (pre y) ==> sat $ pre y
    -- inline |(||||)|
sat $ pre y ==> sat $ pre y
    -- implication
True
\end{code}


\proof{elem/diff}

\h{exprlist}\begin{code}
(x `elem` (ys \\ [x])) == False
\end{code}

The |elem| application is only true if |ys \\ [x]| contains |x|. The expression cannot contain |x|, as if it existed in |ys| it was removed, therefore this application is always |False|.


\theorem{precond/error}
{|precond "error" == propFalse|}


\theorem{precond}
{|precond f ==> reduce $ pre $ body f|}


\proof{sat/reduce}

\ignore\begin{code}
reduce

sat (reduce' x) ==> sat x
    -- inline reduce'
sat reduce $
reduce' :: FuncName -> Prop (Sat VarName)
reduce' f = substP (args f) $ reduce (body f)




sat ((reduce $ pre $ body f) / (argsN f / xs)) && all (sat . pre) xs ==> sat $ pre $ body f / (args f, xs)
    -- \lemma{reduce}
sat (pre (body f) / (args f / xs)) && all (sat . pre) xs ==> sat $ pre $ body f / (args f, xs)
\end{code}





\proof{reduce}

\theorem{reduce}
{|sat (reduce x /# (vs, xs)) ==> sat (x / (vs, xs))|}

\h{exprlist}\begin{code}
sat (reduce x /# (vs, xs)) ==> sat (x / (vs, xs))
    -- inline |reduce|
sat (propMap (\(Sat x k) -> red x k) x /# (vs, xs)) ==> sat (x / (vs, xs))
    -- inline |(/#)| on LHS
sat (propMap (\(Sat x k) -> red x k /# (vs, xs)) x) ==> sat (x / (vs, xs))
    -- promote |sat|
propBool $ propMap (\(Sat x k) -> sat $ red x k /# (vs, xs)) x ==> sat (x / (vs, xs))
    -- \lemma{red}
propBool $ propMap (\(Sat x k) -> sat $ red x k /# (vs, xs)) x ==> propBool $ propMap

\end{code}

\ignore\begin{code}
let foo = (\(Sat x k) -> red x k /# (vs, xs))

sat (propMap foo x) ==> sat (x / (vs, xs))


sat (propMap (f . (/# (vs,xs))) x) ==> sat (x / (vs, xs))
\end{code}

\proof{red}

\theorem{red}
{|sat (red x k /# (vs, xs)) ==> satisfies (x / (vs, xs)) k|}

By induction on x:

\proof[|Var|:]{red}

Now, either |var v| is equal to |Left i| or |Right (on,c)|. We deal with each case in turn.

\h{exprlist}\begin{code}
sat (red v k /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- inline |red|, assuming |var v == Left i|
sat (propLit (Sat i k) /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- inline both substitutions
sat (propLit (Sat x k)) ==> satisfies x k
    -- inline |sat|
satisfies x k ==> satisfies x k
    -- implication
True
\end{code}

Now lets assume it is equal to the |Right|. If |var v == Right (on,(c,i))|, we therefore know that |v| is not a free variable, and the substitution |(/)| will not apply. We also know that |on == Val c xs|, where |xsi == v|.

\h{exprlist}\begin{code}
sat (red v k /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- inline |red|, assuming |var v == Right (on,(c,i))|
sat (red on ((c,i) |> k) /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- knowledge about |on == Val c xs|
sat (red (Make c ys) ((c,i) |> k) /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- \lemma{| ||> |}
sat (red ysi k /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- knowledge that |ysi == v|
sat (red v k /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- \lemma{red}
sat (v / (vs, xs)) k ==> satisfies (v / (vs, xs)) k
    -- equals
True
\end{code}

\proof[|Make|:]{red}

\h{exprlist}\begin{code}
sat (red (Make c xs) k /# (vs, zs)) ==> satisfies (Make c xs / (vs, zs)) k
    -- inline |red|
sat (reduce ((c <| k) /# xs) /# (vs, zs)) ==> satisfies (Make c xs / (vs, zs)) k
    -- \lemma{reduce}
sat (((c <| k) /# xs) / (vs, zs)) ==> satisfies (Make c xs / (vs, zs)) k
    -- \lemma{sat/| <|| |}
sat (Val c xs / (vs, zs)) k ==> satisfies (Make c xs / (vs, zs)) k
    -- continue
\end{code}

\proof[|Call|:]{red}

\h{exprlist}\begin{code}
sat (red (Call f xs) k /# (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- inline |red|
sat (reduce (prePost f k /# xs) /# (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{reduce}
sat ((prePost f k /# xs) / (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{prePost}
sat ((reduce (body f `Sat` k) /# xs) / (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{reduce}
    -- continue
\end{code}

\proof[|Case|:]{red}

\h{exprlist}\begin{code}
sat (red (Call f xs) k /# (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- inline |red|
sat (reduce (prePost f k /# xs) /# (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{reduce}
sat ((prePost f k /# xs) / (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{prePost}
sat ((reduce (body f `Sat` k) /# xs) / (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{reduce}
    -- continue
\end{code}


\h{exprlist}\begin{code}
sat ((reduce $ pre $ body f) / (argsN f / xs)) && all (sat . pre) xs ==> sat $ pre $ body f / (args f, xs)
\end{code}

We can now do case analysis on the body of f.

\h{exprlist}\begin{code}
    -- body f == Var v
sat ((reduce $ pre $ Var v) / (argsN f / xs)) && all (sat . pre) xs ==> sat $ pre $ v / (args f, xs)
    -- apply the substitution
sat ((reduce $ pre $ Var v) / (argsN f / xs)) && all (sat . pre) xs && y `elem` xs ==> sat $ pre y
    -- weaken the precondition
all (sat . pre) xs && y `elem` xs ==> sat $ pre y
    -- \lemma{all/elem}
sat $ pre y ==> sat $ pre y
    -- implication
True
\end{code}

\h{exprlist}\begin{code}
    -- body f == Make c ys
sat ((reduce $ pre $ Make c ys) / (argsN f, xs)) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |pre| on RHS
sat ((reduce $ propAnd $ map pre ys) / (argsN f, xs)) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |reduce|
sat (propAnds (map (reduce . pre) ys) / (argsN f, xs)) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |(/)| on LHS
sat (propAnds (map ((/ (argsN f, xs)) . reduce . pre) ys)) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |sat|
all (sat . ((/ (argsN f, xs)) . reduce . pre) ys) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |(/)| on RHS
all (sat . ((/ (argsN f, xs)) . reduce . pre) ys) && all (sat . pre) xs ==> sat $ pre $ Make c $ map (/ (args f, xs)) ys
    -- inline |pre| on RHS
all (sat . ((/ (argsN f, xs)) . reduce . pre) ys) && all (sat . pre) xs ==> all (sat. pre . (/ (args f, xs))) ys
    -- inductive hypothesis
True
\end{code}




\h{exprlist}\begin{code}
all (sat . reduce . pre) ys sat (propAnds (map (reduce . pre) ys) / (argsN f / xs)) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)

sat ((reduce $ pre $ Make c ys) / (argsN f / xs)) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)
\end{code}



\subsection{Correctness of BP-constraints}


\subsection{Correctness of RE-constraints}


\subsection{Correctness of MP-constraints}

