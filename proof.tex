%include thesis.fmt
%include catch.fmt

%format /# = "/"

\hsdef{\begin{comment}
k,f,c,v,i,on,xs_i,x,ys_i,s,a,ws
vs,xs,y,as,ys,cs
\end{comment}}
\begin{comment}
\begin{code}
import Prelude hiding (($),(/))
import Data.List

infixr 1  $
infixr 0  ==>
class Implies a where (==>) :: a -> a -> Bool
($) :: (a -> b) -> a -> b

instance Implies Bool
instance Implies (Prop a)

type FuncName = String
type CtorName = String
type VarName = String

freeVars :: Expr -> [String]
body   :: FuncName  -> Expr
args   :: FuncName  -> [VarName]
var    :: VarName   -> Maybe (Expr, Selector)
ctors  :: CtorName  -> [CtorName]
type Selector  =  (CtorName, Int)

precond   :: FuncName -> Prop (Sat VarName)
prePost   :: FuncName -> Constraint -> Prop (Sat VarName)
pre ::  Expr -> Prop (Sat Expr)
reduce    :: Prop (Sat Expr) -> Prop (Sat VarName)
red :: Expr -> Constraint -> Prop (Sat VarName)
substP :: Eq alpha => [(alpha,beta)] -> Prop (Sat alpha) -> Prop (Sat beta)

data Sat alpha = Sat alpha Constraint
instance Eq a => Eq (Sat a)

(-<)  :: alpha -> [CtorName] -> Prop (Sat alpha)
(|>)  :: Selector -> Constraint -> Constraint
(<|)  :: CtorName -> Constraint -> Prop (Sat Int)

data Prop alpha
instance Eq a => Eq (Prop a)

propAnd, propOr           :: Prop alpha -> Prop alpha -> Prop alpha
propAnds, propOrs         :: [Prop alpha] -> Prop alpha
propMap                   :: (alpha -> Prop beta) -> Prop alpha -> Prop beta
propTrue, propFalse       :: Prop alpha
propBool                  :: Bool -> Prop alpha
propLit                   :: alpha -> Prop alpha

data Constraint = Constraint

-- variable substitution, replacing free variables
class SubstVar a where (/) :: a -> ([VarName],[Expr]) -> a
instance SubstVar Expr
instance SubstVar Alt
instance SubstVar a => SubstVar (Sat a)
instance SubstVar a => SubstVar (Prop a)

-- equality substitution, replacing items
class SubstRep a b c | c -> b, a -> b, c -> a where (/#) :: a -> b -> c
instance SubstRep (Prop (Sat Int)) ([Int], [Val]) (Prop (Sat Val))
instance SubstRep (Prop (Sat VarName)) ([VarName], [Expr]) (Prop (Sat Expr))
instance SubstRep VarName ([VarName], [Expr]) Expr
instance SubstRep (Prop (Sat VarName)) ([VarName], [Expr]) (Prop (Sat VarName))

instance Eq Val
instance Eq Expr

alt :: Alt -> Prop (Sat a)
pre' :: String -> [Expr] -> Prop (Sat Expr)
\end{code}
\end{comment}


\section{Argument for Correctness}
\label{secC:correct}

\newcommand{\lemma}[1]{(\textit{#1})}
\newcommand{\theorem}[2]{#2 \hspace{5mm} \lemma{#1} \\}
\newcommand{\proof}[2][]{\paragraph{\lemma{#2} \textsf{#1}}}

The algorithm is correct if given a function application whose arguments meet the precondition, it will not call |error|. The proof is structured as an evaluator with an explicit |Bottom| within it -- if this case is encountered the program will crash at runtime. We reason about the evaluator to show satisfying a precondition ensures that |Bottom| will not be reached. This corresponds to a proof of Figures \ref{figC:property_fixp}, \ref{figC:precondition}, \ref{figC:precond_fixp} and \ref{figC:prop}.

To perform the proof, we require various laws about the |-<|, | ||>| and |<||| operators, which we then show hold for each of the three constraint systems.

\subsection{Evaluator}

First we introduce functions and definitions which will be required later.

\begin{code}
data Val  =  Val CtorName [Val]
          |  Bottom

data Expr  =  Make CtorName [Expr]
           |  Call FuncName [Expr]
           |  Var  VarName
           |  Sel  Expr Selector
           |  Case Expr [Alt]

data Alt = Alt CtorName [VarName] Expr

eval :: Expr -> Val
eval (Sel x (c,i)) | c == c' = xs !! i
    where Val c' xs = eval x
eval (Make c xs   ) = Val c (map eval xs)
eval (Call f xs)  | f == "error" = Bottom
                  | otherwise = eval $ body f / (args f, xs)
eval (Case x as   ) = case eval x of
    Val c xs -> head [eval y | Alt c' vs y <- as, c == c']
    Bottom -> Bottom
\end{code}

We have introduced |Sel| for variables bound at a case expression. For the algorithm presented previously, the |Sel| constructor embodies the information returned by the |var| function. In the |Sel| alternative we know that the selector matches, and that we are beneath a |Case| on the same expression |x|. The behaviour of |eval| if there are free variables is undefined.

We make use of |(/)|, which we have redefined as a substitution operator -- we write |x / (vs,ys)| to denote replacing the free variables |vs| in |x| with |ys|. We use |(/)| instead of |substP| in the proofs. There is no |eval| alternative for |Var|, as an expression at evaluation will not have any free variables, as substitution will remove them. We can assume the argument to |eval| has no free variables. The free variables of a function are its arguments.

We also make use of a number of auxiliaries throughout the proof:

\begin{code}
isBottom :: Val -> Bool
isBottom Bottom = True
isBottom (Val c xs) = any isBottom xs

valCtor :: Val -> Maybe CtorName
valCtor (Val c xs) = Just c
valCtor Bottom = Nothing

propIsTrue :: Prop () -> Bool
propIsTrue = (==) propTrue

propTaut :: (alpha -> Bool) -> Prop alpha -> Bool
propTaut f = propIsTrue . propMap (propBool . f)

satE' :: Prop (Sat Expr) -> Bool
satE' = propTaut satE

satE :: Sat Expr -> Bool
satE (Sat x k) = sat (eval x) k

satV' :: Prop (Sat Val) -> Bool
satV' = propTaut satV

satV :: Sat Val -> Bool
satV (Sat v k) = sat v k

sat :: Val -> Constraint -> Bool
\end{code}

Of these functions, |sat| is primitive and different for each constraint language. All the expressions given to |satE| must have no free variables, as |eval| cannot deal with them.

\subsection{Theorems}

We wish to prove:

\theorem{pre/eval}
{|satE' $ pre x ==> not $ isBottom $ eval x|}

In particular this requires the following theorems about the constraint language:

\theorem{satV/|-<|}
{|satV' $ x -< cs ==> maybe True (`elem` cs) (valCtor x)|}

\theorem{sat/| ||> |}
{|sat (Val c xs) ((c,i) ||> k) ==> sat (xs !! i) k|}

\theorem{sat/| <|| |}
{|satV' $ (c <|| k) /# ([1..],xs) ==> sat (Val c xs) k|}

We will also need the following general theorems:

\theorem{precond/error}
{|precond "error" == propFalse|}

\theorem{precond}
{|precond f ==> reduce $ pre $ body f|}

\theorem{reduce}
{|satE' $ reduce x /# (vs,xs) ==> satE' $ x / (vs, xs)|}

\theorem{red}
{|satE' $ red x k /# (vs,xs) ==> sat (eval $ x / (vs, xs)) k|}

\theorem{pre}
{|satE' (pre x / (vs, ys)) && all (satE' . pre) ys ==> satE' $ pre $ x / (vs, ys)|}

\theorem{satE/|-<|}
{|satV' (eval x -< cs) == satE' (x -< cs)|}

\theorem{elem}
{|(x `elem` (xs \\ [x])) == False|}

\subsubsection{The Proof}

We prove each lemma in turn.

\proof{pre/eval}

\h{expr}\begin{code}
satE' $ pre x ==> not $ isBottom $ eval x
\end{code}

By induction. We do not need to consider |Var| as |eval| cannot be called on expressions with free variables.

\proof[|Sel|:]{pre/eval}

The initial definition is:

\begin{code}
eval (Sel x (c,i)) | c == c' = xs !! i
    where Val c' xs = eval x
\end{code}

We know that any \ignore|Sel x _| value must be contained within a \ignore|Case x _| expression. If we assume that the original |Case| did satisfy its precondition, we obtain:

\h{exprlist}\begin{code}
satE' $ pre $ Case x as ==> satE' $ pre $ x
    -- inline |pre|
satE' $ pre x `propAnd` propAnds (map alt as) ==> satE' $ pre $ x
    -- inline |satE'|
satE' (pre x) && satE' (propAnds $ map alt as) ==> satE' $ pre $ x
    -- weaken implication
satE' $ pre x ==> satE' $ pre $ x
    -- equals
True
\end{code}

\proof[|Make|:]{pre/eval}

The initial definition is:

\begin{code}
eval (Make c xs) = Val c (map eval xs)
\end{code}

This does not produce |Bottom| if all recursive calls to |eval| are on values which satisfy |pre|. We can write this as:

\h{exprlist}\begin{code}
satE' $ pre $ Make c xs  ==> all (satE' . pre) xs
    -- inline |pre|
satE' $ propAnds $ map pre xs ==> all (satE' . pre) xs
    -- inline |satE'|
and $ map satE' $ map pre xs  ==> all (satE' . pre) xs
    -- |map f . map g == map (f . g)|
and $ map (satE' . pre) xs ==> all (satE' . pre) xs
    -- |and . map f == all f|
all (satE' . pre) xs ==> all (satE' . pre) xs
    -- equal
True
\end{code}

\proof[|Call|:]{pre/eval}

The initial definition is:

\begin{code}
eval (Call f xs)  | f == "error" = Bottom
                  | otherwise = eval $ body f / (args f, xs)
\end{code}

There are two ways to get |Bottom| from this fragment. The first is the explicit |Bottom|, and the second is the recursive call to |eval|. The first |Bottom| is avoided under the condition:

\h{exprlist}\begin{code}
satE' $ pre $ Call f xs ==> f /= "error"
    -- inline |pre|
satE' $ (precond f /# (args f, xs)) `propAnd` propAnds (map pre xs) ==> f /= "error"
    -- inline |satE'|
satE' (precond f /# (args f, xs)) && all (satE' . pre) xs ==> f /= "error"
    -- weaken implication
satE' (precond f /# (args f, xs)) ==> f /= "error"
\end{code}

We can now perform case analysis on |f|, assuming it either is, or is not, equal to |"error"|.

\h{exprlist}\begin{code}
satE' (precond f /# (args f, xs)) ==> f /= "error"
    -- assume |f /= "error"|
satE' (precond f /# (args f, xs)) ==> True
    -- implication
True
\end{code}

\h{exprlist}\begin{code}
satE' (precond f /# (args f, xs)) ==> f /= "error"
    -- assume |f == "error"|
satE' (precond f /# (args f, xs)) ==> False
    -- implication
not $ satE' (precond "error" /# (args f, xs))
    -- \lemma{precond/error}
not $ satE' $ (propFalse /# (args f, xs))
    -- inline |(/)|
not $ satE' propFalse
    -- inline |satE'|
not $ False
    -- inline |not|
True
\end{code}

This leaves us with the call to |eval|, namely:

\h{exprlist}\begin{code}
satE' $ pre $ Call f xs ==> satE' $ pre $ body f / (args f, xs)
    -- inline pre on LHS
satE' $ (precond f /# (args f, xs)) `propAnd` propAnds (map pre xs) ==> satE' $ pre $ body f / (args f, xs)
    -- inline |satE'|
satE' (precond f /# (args f, xs)) && all (satE' . pre) xs ==> satE' $ pre $ body f / (args f, xs)
    -- \lemma{precond}
satE' ((reduce $ pre $ body f) /# (args f, xs)) && all (satE' . pre) xs ==> satE' $ pre $ body f / (args f, xs)
    -- \lemma{reduce}
satE' (pre (body f) / (args f, xs)) && all (satE' . pre) xs ==> satE' $ pre $ body f / (args f, xs)
    -- \lemma{pre/subst}
True
\end{code}

\proof[|Case|:]{pre/eval}

\begin{code}
eval (Case x as   ) = case eval x of
    Val c xs -> head [eval y | Alt c' vs y <- as, c == c']
    Bottom -> Bottom
\end{code}

This equation may generate |Bottom| in two ways -- either the explicit |Bottom| may be taken, or the nested |eval| may be taken. In both cases, if we can prove the expression passed to |eval| satisfies its precondition, then we can eliminate the possibility of |Bottom|.

We first prove that the explicit |Bottom| is not reached, assuming the initial expression does not violate the precondition check.

\h{exprlist}\begin{code}
satE' $ pre $ Case x as ==> satE' $ pre x
    -- inline |pre|
satE' $ pre x `propAnd` propAnds (map alt as) ==> satE' $ pre x
    -- inline |satE'|
satE' (pre x) && satE' (propAnds $ map alt as) ==> satE' $ pre x
    -- weaken implication
satE' $ pre x ==> satE' $ pre x
    -- equal
True
\end{code}

We now need to ensure that the other call to |eval| meets its precondition. To simplify the proof we only consider case expressions containing the one alternative which is taken. Because the source language has static typing and complete alternatives, we know there will be exactly one matching alternative. All non-matching alternatives are filtered out, so this simplification is valid. We can assume that |eval x == Val c xs|.

\h{exprlist}\begin{code}
satE' $ pre $ Case x [Alt c vs y] ==> satE' $ pre y
    -- inline |pre|
satE' $ pre x `propAnd` propAnds (map alt [Alt c vs y]) ==> satE' $ pre y
    -- inline |map|
satE' $ pre x `propAnd` propAnds [alt $ Alt c vs y] ==> satE' $ pre y
    -- inline |propAnds|
satE' $ pre x `propAnd` alt (Alt c vs y) ==> satE' $ pre y
    -- inline |satE'|
satE' (pre x) && satE' (alt $ Alt c vs y) ==> satE' $ pre y
    -- weaken implication
satE' $ alt $ Alt c vs y ==> satE' $ pre y
    -- inline |alt|
satE' $ x -< (ctors c \\ [c]) `propOr` pre y ==> satE' $ pre y
    -- inline |satE'|
satE' (x -< (ctors c \\ [c])) || satE' (pre y) ==> satE' $ pre y
    -- \lemma{satE/|-<|}
satV' (eval x -< (ctors c \\ [c])) || satE' (pre y) ==> satE' $ pre y
    -- \lemma{satV/|-<|}
maybe True (`elem` (ctors c \\ [c])) (valCtor $ eval x) || satE' (pre y) ==> satE' $ pre y
    -- |eval x == Val c xs|
maybe True (`elem` (ctors c \\ [c])) (valCtor $ Val c xs) || satE' (pre y) ==> satE' $ pre y
    -- inline |valCtor|
maybe True (`elem` (ctors c \\ [c])) (Just c) || satE' (pre y) ==> satE' $ pre y
    -- inline |maybe|
c `elem` (ctors c \\ [c]) || satE' (pre y) ==> satE' $ pre y
    -- \lemma{elem}
False || satE' (pre y) ==> satE' $ pre y
    -- inline |(||||)|
satE' $ pre y ==> satE' $ pre y
    -- equals
True
\end{code}

\proof{elem}

\h{expr}\begin{code}
(x `elem` (ys \\ [x])) == False
\end{code}

The |elem| application is only true if |ys \\ [x]| contains |x|. The expression cannot contain |x|, as if it existed in |ys| it was removed, therefore this application is always |False|.

\proof{precond/error}

\h{expr}\begin{code}
precond "error" == propFalse
\end{code}

The initial computation of |precond| will return |propFalse|. All successive computations will be at least as restrictive, therefore the result must be |propFalse|.

\proof{precond}

\h{expr}\begin{code}
precond f ==> reduce $ pre $ body f
\end{code}

The definition of |precond f| is a conjunction where the second conjunct is |reduce $ pre $ body f|, therefore |precond f| is at least as restrictive as the alternative.


\proof{satE/|-<|}

\h{exprlist}\begin{code}
satV' (eval x -< cs) == satE' (x -< cs)
    -- inline |satV'| and |satE'|
propTaut satV (eval x -< cs) == propTaut satE (x -< cs)
    -- inline |propTaut| and reduce common bits
propMap (propBool . satV) (eval x -< cs) == propMap (propBool . satE) (x -< cs)
\end{code}

Now we can use the type signature of |-<|:

\begin{code}
(-<) :: alpha -> [CtorName] -> Prop (Sat alpha)
\end{code}

The theorems for free work \cite{wadler:theorems} shows that the first argument will end up as the first argument of the |Sat| constructor, unmodified and unexamined. The |satE| function applies |eval| to the first argument of |Sat|, therefore both these pieces of code are equivalent.


\proof{pre}

\h{exprlist}\begin{code}
satE' (pre x / (vs, ys)) && all (satE' . pre) ys ==> satE' $ pre $ x / (vs, ys)
\end{code}

This proof is by case analysis on |x|. We assume that all free variables in |x| are bound in |vs|. To shorten all the proofs we hide the |all (satE' . pre) ys| term, as it is never manipulated.

\proof[|Var|:]{pre}

\h{exprlist}\begin{code}
satE' $ pre x / (vs, ys) ==> satE' $ pre $ x / (vs, ys)
    -- |x == Var v|
satE' $ pre (Var v) / (vs, ys) ==> satE' $ pre $ Var v / (vs, ys)
    -- inline |pre| on LHS
satE' $ propTrue / (vs, ys) ==> satE' $ pre $ Var v / (vs, ys)
    -- inline |(/)| on LHS
satE' propTrue ==> satE' $ pre $ Var v / (vs, ys)
    -- inline |satE'|
True ==> satE' $ pre $ Var v / (vs, ys)
    -- reintroduce hidden term
all (satE' . pre) ys ==> satE' $ pre $ Var v / (vs, ys)
\end{code}

We know that |v| will be a member of |vs|, and that the result will be |pre y|, where |y| is drawn from |ys|. Since all |ys| satisfy the precondition, then so will the particular |y| we substitute.

\proof[|Sel|:]{pre}

\h{exprlist}\begin{code}
satE' $ pre x / (vs, ys) ==> satE' $ pre $ x / (vs, ys)
    -- |x == Sel x s|
satE' $ pre (Sel x s) / (vs, ys) ==> satE' $ pre $ Sel x s / (vs, ys)
    -- inline |(/)| on RHS
satE' $ pre (Sel x s) / (vs, ys) ==> satE' $ pre $ Sel (x / (vs,ys)) s
    -- inline |pre| on RHS
satE' $ pre (Sel x s) / (vs, ys) ==> satE' $ propTrue
    -- inline |satE'| on RHS
satE' $ pre (Sel x s) / (vs, ys) ==> True
    -- implication
True
\end{code}

\proof[|Make|:]{pre}

\h{exprlist}\begin{code}
satE' $ pre x / (vs, ys) ==> satE' $ pre $ x / (vs, ys)
    -- |x == Make c xs|
satE' $ pre (Make c xs) / (vs, ys) ==> satE' $ pre $ Make c xs / (vs, ys)
    -- inline |(/)| on RHS
satE' $ pre (Make c xs) / (vs, ys) ==> satE' $ pre $ Make c $ map (/ (vs, ys)) xs
    -- inline |pre| on both sides
satE' $ propAnds (map pre xs) / (vs, ys) ==> satE' $ propAnds $ map (pre . (/ (vs, ys))) xs
    -- inline |(/)| on LHS
satE' $ propAnds $ map ((/ (vs,ys)) . pre) xs ==> satE' $ propAnds $ map (pre . (/ (vs, ys))) xs
    -- inline |satE'| on both sides
all (satE' . (/ (vs,ys)) . pre) xs ==> all (satE' . pre . (/ (vs, ys))) xs
    -- \lemma{pre}
True
\end{code}

\proof[|Call|:]{pre}

\h{exprlist}\begin{code}
satE' $ pre x / (vs, ys) ==> satE' $ pre $ x / (vs, ys)
    -- |x == Call f xs|
satE' $ pre (Call f xs) / (vs, ys) ==> satE' $ pre $ Call f xs / (vs, ys)
    -- inline |(/)| on RHS
satE' $ pre (Call f xs) / (vs, ys) ==> satE' $ pre $ Call f $ map (/ (vs, ys)) xs
\end{code}

Now we will work on each side individually, starting with LHS:

\h{exprlist}\begin{code}
satE' $ pre (Call f xs) / (vs, ys)
    -- inline |pre|
satE' $ (pre' f xs `propAnd` propAnds (map pre xs)) / (vs,ys)
    -- inline |(/)|
satE' $ (pre' f xs / (vs,ys)) `propAnd` propAnds (map (pre . (/ (vs,ys))) xs)
    -- inline |satE'|
satE' (pre' f xs / (vs,ys)) && all (satE' . pre . (/ (vs,ys))) xs
\end{code}

And the RHS:

\h{exprlist}\begin{code}
satE' $ pre $ Call f $ map (/ (vs, ys)) xs
    -- inline |pre|
satE' $ (pre' f (map (/ (vs, ys)) xs)) `propAnd` propAnds (map (pre . (/ (vs, ys))) xs)
    -- inline |satE'|
satE' (pre' f (map (/ (vs, ys)) xs)) && all (satE' . pre . (/ (vs, ys))) xs
\end{code}

We can now combine these sides, eliminating the common bit:

\h{exprlist}\begin{code}
satE' $ pre' f xs / (vs,ys) ==> satE' $ pre' f (map (/ (vs, ys)) xs)
    -- inline |pre'|
satE' $ (precond f /# (args f, xs)) /# (vs,ys) ==> satE' $ precond f /# (args f, map (/ (vs, ys)) xs)
    -- using the knowledge that |precond f| only has the free variables |args f|
    -- we can inline |(/) on the left
satE' $ precond f /# (args f, map (/ (vs,ys)) xs) ==> satE' $ precond f /# (args f, map (/ (vs, ys)) xs)
    -- equal
True
\end{code}

\proof[|Case|:]{pre}

\h{exprlist}\begin{code}
satE' $ pre x / (vs, ys) ==> satE' $ pre $ x / (vs, ys)
    -- |x == Case x as|
satE' $ pre (Case x as) / (vs, ys) ==> satE' $ pre $ Case x as / (vs, ys)
    -- inline |(/)| on RHS
satE' $ pre (Case x as) / (vs, ys) ==> satE' $ pre $ Case (x / (vs, ys)) (map (/ (vs, ys)) as)
    -- inline |pre| on both sides
satE' $ (pre x `propAnd` propAnds (map alt as)) / (vs, ys) ==> satE' $ pre (x / (vs, ys)) `propAnd` propAnds (map (alt . (/ (vs, ys))) as)
    -- inline |(/)| on RHS
satE' $ (pre x / (vs, ys)) `propAnd` propAnds (map ((/ (vs, ys)) . alt) as)  ==> satE' $ pre (x / (vs, ys)) `propAnd` propAnds (map (alt . (/ (vs, ys))) as)
    -- inline |satE'|
satE' (pre x / (vs, ys)) && all (satE' . (/ (vs, ys)) . alt) as  ==> satE' (pre (x / (vs, ys))) && all (satE' . alt . (/ (vs, ys))) as
    -- \lemma{pre}
all (satE' . (/ (vs, ys)) . alt) as  ==> all (satE' . alt . (/ (vs, ys))) as
    -- implication over |all|
satE' $ alt a / (vs, ys) ==> satE' $ alt $ as / (vs, ys)
    -- instantiate |a| as a general |Alt|
satE' $ alt (Alt c ws y) / (vs, ys) ==> satE' $ alt $ Alt c ws y / (vs, ys)
    -- inline |(/)| on RHS
satE' $ alt (Alt c ws y) / (vs, ys) ==> satE' $ alt $ Alt c ws (y / (vs, ys))
    -- inline |alt|
satE' $ (x -< (ctors c \\ [c]) `propOr` pre y) / (vs, ys) ==> satE' $ (x / (vs,ys) -< (ctors c \\ [c])) `propOr` pre (y / (vs, ys))
    -- let |cs == ctors c \\ [c]
satE' $ (x -< cs `propOr` pre y) / (vs, ys) ==> satE' $ (x / (vs,ys) -< cs) `propOr` pre (y / (vs, ys))
    -- inline |(/)| on LHS
satE' $ (x / (vs,ys) -< cs) `propOr` (pre y / (vs, ys)) ==> satE' $ (x / (vs,ys) -< cs) `propOr` pre (y / (vs, ys))
    -- inline |satE'| on both sides
satE' (x / (vs,ys) -< cs) || satE' (pre y / (vs, ys)) ==> satE' (x / (vs,ys) -< cs) || satE' (pre (y / (vs, ys)))
    -- remove duplicate bits on each side
satE' $ pre y / (vs, ys) ==> satE' $ pre $ y / (vs, ys)
    -- \lemma{pre}
True
\end{code}


\proof{reduce}

We wish to prove:

\h{exprlist}\begin{code}
satE' $ reduce x /# (vs,xs) ==> satE' $ x / (vs, xs)
    -- inline |reduce|
satE' $ propMap (\(Sat x k) -> red x k) x /# (vs,xs) ==> satE' $ x / (vs, xs)
    -- inline |(/)| on LHS
satE' $ propMap (\(Sat x k) -> red x k /# (vs,xs)) x ==> satE' $ x / (vs, xs)
    -- inline |(/)| on RHS
satE' $ propMap (\(Sat x k) -> red x k /# (vs,xs)) x ==> satE' $ propMap (\(Sat x k) -> propLit $ Sat x k / (vs, xs)) x
    -- inline |(/)| on RHS
satE' $ propMap (\(Sat x k) -> red x k /# (vs,xs)) x ==> satE' $ propMap (\(Sat x k) -> propLit $ Sat (x / (vs, xs)) k) x
    -- inline |satE'|
propIsTrue $ propMap (\(Sat x k) -> propBool $ satE' $ red x k /# (vs,xs)) x ==> propIsTrue $ propMap (\(Sat x k) -> propBool $ satE' $ propLit $ Sat (x / (vs, xs)) k) x
    -- lift |propMap| over |(==>)|
satE' $ red x k /# (vs,xs) ==> satE' $ propLit $ Sat (x / (vs, xs)) k
    -- inline |satE'| on RHS
satE' $ red x k /# (vs,xs) ==> satE $ Sat (x / (vs, xs)) k
    -- inline |satE| on RHS
satE' $ red x k /# (vs,xs) ==> sat (eval $ x / (vs, xs)) k
    -- \lemma{red}
True
\end{code}


\proof{red}

We wish to prove:

\h{expr}\begin{code}
satE' $ red x k /# (vs,xs) ==> sat (eval $ x / (vs, xs)) k
\end{code}

We do so by case analysis on the expression |x|.

\proof[|Var|:]{red}

\h{exprlist}\begin{code}
satE' $ red x k /# (vs,xs) ==> sat (eval $ x / (vs, xs)) k
    -- |x == Var v|
satE' $ red (Var v) k /# (vs,xs) ==> sat (eval $ Var v / (vs, xs)) k
    -- inline |red|
satE' $ propLit (Sat v k) /# (vs,xs) ==> sat (eval $ Var v / (vs, xs)) k
    -- inline |(/)| on LHS
satE' $ propLit (Sat (v /# (vs,xs)) k) ==> sat (eval $ Var v / (vs, xs)) k
    -- promote |v| on LHS to |Var v|
    -- because |(/)| operates identically on both
satE' $ propLit (Sat (Var v / (vs,xs)) k) ==> sat (eval $ Var v / (vs, xs)) k
    -- inline |satE'|
satE (Sat (Var v / (vs,xs)) k) ==> sat (eval $ Var v / (vs, xs)) k
    -- inline |satE|
sat (eval $ Var v / (vs,xs)) k ==> sat (eval $ Var v / (vs, xs)) k
    -- equal
True
\end{code}




%if 0


WANT: satE' (pre x /# (vs, ys)) && all (satE' . pre) ys ==> satE' $ pre $ x / (vs, ys)






    -- inline |pre| on both sides

satE' $ pre (Call f xs) /# (vs, ys) ==> satE' $ pre $ Call f $ map (/ (vs, ys)) xs


satE' $ propAnds (map pre xs) /# (vs, ys) ==> satE' $ propAnds $ map (pre . (/ (vs, ys))) xs
    -- inline |(/)| on LHS
satE' $ propAnds $ map ((/# (vs,ys)) . pre) xs ==> satE' $ propAnds $ map pre (/ (vs, ys)) xs
    -- inline |satE'| on both sides
all (satE' . (/# (vs,ys)) . pre) xs ==> all (satE' . pre . (/ (vs, ys))) xs
    -- \lemma{pre}
True
\end{code}






\proof{sat/reduce}

\ignore\begin{code}
reduce

sat (reduce' x) ==> sat x
    -- inline reduce'
sat reduce $
reduce' :: FuncName -> Prop (Sat VarName)
reduce' f = substP (args f) $ reduce (body f)




sat ((reduce $ pre $ body f) / (argsN f / xs)) && all (sat . pre) xs ==> sat $ pre $ body f / (args f, xs)
    -- \lemma{reduce}
sat (pre (body f) / (args f / xs)) && all (sat . pre) xs ==> sat $ pre $ body f / (args f, xs)
\end{code}





\proof{reduce}

\theorem{reduce}
{|sat (reduce x /# (vs, xs)) ==> sat (x / (vs, xs))|}

\h{exprlist}\begin{code}
sat (reduce x /# (vs, xs)) ==> sat (x / (vs, xs))
    -- inline |reduce|
sat (propMap (\(Sat x k) -> red x k) x /# (vs, xs)) ==> sat (x / (vs, xs))
    -- inline |(/)| on LHS
sat (propMap (\(Sat x k) -> red x k /# (vs, xs)) x) ==> sat (x / (vs, xs))
    -- promote |sat|
propBool $ propMap (\(Sat x k) -> sat $ red x k /# (vs, xs)) x ==> sat (x / (vs, xs))
    -- \lemma{red}
propBool $ propMap (\(Sat x k) -> sat $ red x k /# (vs, xs)) x ==> propBool $ propMap

\end{code}

\ignore\begin{code}
let foo = (\(Sat x k) -> red x k /# (vs, xs))

sat (propMap foo x) ==> sat (x / (vs, xs))


sat (propMap (f . (/# (vs,xs))) x) ==> sat (x / (vs, xs))
\end{code}

\proof{red}

\theorem{red}
{|sat (red x k /# (vs, xs)) ==> satisfies (x / (vs, xs)) k|}

By induction on x:

\proof[|Var|:]{red}

Now, either |var v| is equal to |Left i| or |Right (on,c)|. We deal with each case in turn.

\h{exprlist}\begin{code}
sat (red v k /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- inline |red|, assuming |var v == Left i|
sat (propLit (Sat i k) /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- inline both substitutions
sat (propLit (Sat x k)) ==> satisfies x k
    -- inline |sat|
satisfies x k ==> satisfies x k
    -- implication
True
\end{code}

Now lets assume it is equal to the |Right|. If |var v == Right (on,(c,i))|, we therefore know that |v| is not a free variable, and the substitution |(/)| will not apply. We also know that |on == Val c xs|, where |xsi == v|.

\h{exprlist}\begin{code}
sat (red v k /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- inline |red|, assuming |var v == Right (on,(c,i))|
sat (red on ((c,i) |> k) /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- knowledge about |on == Val c xs|
sat (red (Make c ys) ((c,i) |> k) /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- \lemma{| ||> |}
sat (red ysi k /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- knowledge that |ysi == v|
sat (red v k /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- \lemma{red}
sat (v / (vs, xs)) k ==> satisfies (v / (vs, xs)) k
    -- equals
True
\end{code}

\proof[|Make|:]{red}

\h{exprlist}\begin{code}
sat (red (Make c xs) k /# (vs, zs)) ==> satisfies (Make c xs / (vs, zs)) k
    -- inline |red|
sat (reduce ((c <| k) /# xs) /# (vs, zs)) ==> satisfies (Make c xs / (vs, zs)) k
    -- \lemma{reduce}
sat (((c <| k) /# xs) / (vs, zs)) ==> satisfies (Make c xs / (vs, zs)) k
    -- \lemma{sat/| <|| |}
sat (Val c xs / (vs, zs)) k ==> satisfies (Make c xs / (vs, zs)) k
    -- continue
\end{code}

\proof[|Call|:]{red}

\h{exprlist}\begin{code}
sat (red (Call f xs) k /# (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- inline |red|
sat (reduce (prePost f k /# xs) /# (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{reduce}
sat ((prePost f k /# xs) / (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{prePost}
sat ((reduce (body f `Sat` k) /# xs) / (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{reduce}
    -- continue
\end{code}

\proof[|Case|:]{red}

\h{exprlist}\begin{code}
sat (red (Call f xs) k /# (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- inline |red|
sat (reduce (prePost f k /# xs) /# (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{reduce}
sat ((prePost f k /# xs) / (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{prePost}
sat ((reduce (body f `Sat` k) /# xs) / (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{reduce}
    -- continue
\end{code}


\h{exprlist}\begin{code}
sat ((reduce $ pre $ body f) / (argsN f / xs)) && all (sat . pre) xs ==> sat $ pre $ body f / (args f, xs)
\end{code}

We can now do case analysis on the body of f.

\h{exprlist}\begin{code}
    -- body f == Var v
sat ((reduce $ pre $ Var v) / (argsN f / xs)) && all (sat . pre) xs ==> sat $ pre $ v / (args f, xs)
    -- apply the substitution
sat ((reduce $ pre $ Var v) / (argsN f / xs)) && all (sat . pre) xs && y `elem` xs ==> sat $ pre y
    -- weaken the precondition
all (sat . pre) xs && y `elem` xs ==> sat $ pre y
    -- \lemma{all/elem}
sat $ pre y ==> sat $ pre y
    -- implication
True
\end{code}

\h{exprlist}\begin{code}
    -- body f == Make c ys
sat ((reduce $ pre $ Make c ys) / (argsN f, xs)) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |pre| on RHS
sat ((reduce $ propAnd $ map pre ys) / (argsN f, xs)) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |reduce|
sat (propAnds (map (reduce . pre) ys) / (argsN f, xs)) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |(/)| on LHS
sat (propAnds (map ((/ (argsN f, xs)) . reduce . pre) ys)) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |sat|
all (sat . ((/ (argsN f, xs)) . reduce . pre) ys) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |(/)| on RHS
all (sat . ((/ (argsN f, xs)) . reduce . pre) ys) && all (sat . pre) xs ==> sat $ pre $ Make c $ map (/ (args f, xs)) ys
    -- inline |pre| on RHS
all (sat . ((/ (argsN f, xs)) . reduce . pre) ys) && all (sat . pre) xs ==> all (sat. pre . (/ (args f, xs))) ys
    -- inductive hypothesis
True
\end{code}




\h{exprlist}\begin{code}
all (sat . reduce . pre) ys sat (propAnds (map (reduce . pre) ys) / (argsN f / xs)) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)

sat ((reduce $ pre $ Make c ys) / (argsN f / xs)) && all (sat . pre) xs ==> sat $ pre $ Make c ys / (args f, xs)
\end{code}



\subsection{Correctness of BP-constraints}


\subsection{Correctness of RE-constraints}


\subsection{Correctness of MP-constraints}

