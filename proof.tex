%include thesis.fmt

%format <| = "\mathbin{\lhd}"
%format |> = "\mathbin{\rhd}"
%format -< = "\mbox{\ensuremath{<\hspace{-1em}-}}"
%format :- = "\!\rightsquigarrow{}\!"
%format :* = "\star{}"
%format :| = "\ddagger{}"
%format ^. = "\!\cdot{}\!"
%format ^* = "^\ast{}\!"
%format ^ = "\;\hat{}\;"
%format undefined   = "\Varid{undefined}"
%format `mergeVal` = "\sqcap{}"
%format mergeVal = "(\sqcap{})"
%format && = "\mathrel{\hbox{\textsf{\& \hspace{-1em} \&}}}"
%format || = "\mathrel{||}"

%format `propAnd` = "\;\ensuremath{\wedge}\;"
%format `propOr` = "\;\ensuremath{\vee}\;"
%format propAnd = "(\ensuremath{\wedge})"
%format propOr = "(\ensuremath{\vee})"
%format propAnds = "\mathsf{andP}"
%format propOrs = "\mathsf{orP}"
%format propLit = "\mathsf{lit}"
%format propMap = "\mathsf{mapP}"
%format propTrue = "\mathsf{true}"
%format propFalse = "\mathsf{false}"
%format propBool = "\mathsf{bool}"
%format propIsTrue = "\mathsf{isTrue}"
%format propIsFalse = "\mathsf{isFalse}"
%format `propImp` = "\ensuremath{\Longrightarrow}"
%format propImp = "(\ensuremath{\Longrightarrow})"
%format ==> = "\ensuremath{\Rightarrow}"

%format pre' = pre "^{\prime}"

%format `Sat` = "\backtick{Sat}"

\newcommand{\rec}[1]{\hspace{-0.75ex}_{#1}}
%format Rec0 = "\rec{\mathrm{0}}"
%format RecN = "\rec{\Varid{n}}"
%format RecN1 = "\rec{\Varid{n}\text{\tiny{+}}\mathrm{1}}"


\newcommand{\para}[1]{\vspace{2mm}\noindent\textbf{#1}}


\chapter{Pattern Match Analysis Proof}

\section{Preliminaries}

\begin{code}
type Selector  =  (CtorName, Int)
type ArgPos    =  Int

var    :: VarName   -> Either ArgPos (Expr, Selector)
isRec  :: Selector  -> Bool
\end{code}

\begin{code}
data Prop alpha

propAnd, propOr           :: Prop alpha -> Prop alpha -> Prop alpha
propAnds, propOrs         :: [Prop alpha] -> Prop alpha
propMap                   :: (alpha -> Prop beta) -> Prop alpha -> Prop beta
propTrue, propFalse       :: Prop alpha
propBool                  :: Bool -> Prop alpha
propLit                   :: alpha -> Prop alpha
\end{code}

\begin{code}
data Sat alpha = Sat alpha Constraint

(-<)  :: alpha -> [CtorName] -> Prop (Sat alpha)
(|>)  :: Selector -> Constraint -> Constraint
(<|)  :: CtorName -> Constraint -> Prop (Sat ArgPos)
\end{code}

\begin{code}
precond   :: FuncName -> Prop (Sat ArgPos)
prePost   :: FuncName -> Constraint -> Prop (Sat ArgPos)
reduce    :: Prop (Sat Expr) -> Prop (Sat ArgPos)

substP ::  [alpha] -> Prop (Sat ArgPos) -> Prop (Sat alpha)
substP xs p = propMap (\(Sat i k ) -> propLit $ Sat (xs!!i) k) p
\end{code}

\begin{code}
data Constraint  =  Any
                 |  Con CtorName [Constraint]
\end{code}

\begin{code}
pre ::  Expr -> Prop (Sat Expr)
pre (EVar v       ) = propTrue
pre (ECon c xs_   ) = propAnds (map pre xs_)
pre (EFun f xs_   ) = pre' f xs `propAnd` propAnds (map pre xs_)
    where pre' f xs = substP xs (precond f)
pre (ECase x as_  ) = pre x `propAnd` propAnds (map alt as_)
    where alt (EAlt c vs_ y) = on -< (ctors c \\ [c]) `propOr` pre y
\end{code}

\ignore\begin{code}
precond  :: FuncName -> Prop (Sat ArgPos)
precond Rec0   f =  if f == "error" then propFalse else propTrue
precond RecN1  f =  precond RecN f `propAnd` reduce (pre{precond RecN} (body f))
\end{code}

\begin{code}
reduce :: Prop (Sat Expr) -> Prop (Sat ArgPos)
reduce = propMap (\(Sat x k) -> red x k)

red :: Expr -> Constraint -> Prop (Sat ArgPos)
red (EVar   v     )  k =  case var v of
                            Left   i       -> propLit (i `Sat` k)
                            Right  (on,c)  -> red on (c |> k)
red (ECon c xs_   )  k =  reduce $ substP xs_ (c <| k)
red (EFun f xs_   )  k =  reduce $ substP xs_ (prePost f k)
red (ECase x as_  )  k =  propAnds (map alt as_)
    where alt (EAlt c vs_ y) = reduce (on -< (ctors c \\ [c])) `propOr` red y k
\end{code}

\ignore\begin{code}
prePost :: FuncName -> Constraint -> Prop (Sat ArgPos)
prePost Rec0   f k =  propTrue
prePost RecN1  f k =  prePost RecN f k `propAnd` reduce{prePost RecN} (propLit $ body f `Sat` k)
\end{code}



\section{Argument for Correctness}
\label{secC:correct}

\newcommand{\lemma}[1]{(\textit{#1})}
\newcommand{\theorem}[2]{#2  \hspace{5mm} \lemma{#1} \\}
\newcommand{\proof}[2][]{\paragraph{\lemma{#2} \textsf{#1}}}

The algorithm is correct if given a function application whose arguments meet the precondition, it will not call |error|. The proof is structured as an evaluator with an explicit |Bottom| within it -- if this case is encountered the program crashes. We reason about the evaluator to show satisfying a precondition ensures that |Bottom| will not be reached. This corresponds to a proof of Figures \ref{figC:property_fixp}, \ref{figC:precondition}, \ref{figC:precond_fixp} and \ref{figC:prop}.

To perform the proof, we require various laws about the |:<|, | ||>| and |<||| operators, which we then show hold for each of the three constraint systems.

\subsection{Evaluator}

First we introduce functions and definitions which will be required later.

\begin{code}
data Val  =  Val CtorName [Val]
          |  Bottom

data Expr = Make CtorName [Expr]
          | Call FuncName [Expr]
          | Var  VarName
          | Case Expr [Alt]

data Alt = Alt CtorName [VarName] Expr

eval :: Expr -> Val
eval (Make c xs_   ) = Val c (map eval xs_)
eval (Call f xs_)  | f == "error" = Bottom
                   | otherwise = eval $ subst (zip (args f) xs_) $ body f
eval (Case x as_  ) = case eval x of
    Val c xs_ -> eval $ head [y / (vs_, map uneval xs_) | Alt c' vs_ y <- as_, c == c']
    Bottom -> Bottom

uneval :: Val -> Expr
uneval (Val c xs_)  = Make c (map uneval xs_)
uneval Bottom       = Call "error" []
\end{code}

We make use of |(/)|, which we have redefined as a substitution operator -- we write |x / (vs_,ys_)| to denote replacing the free variables |vs_| in |x| with |ys_|. There is no |eval| alternative for |Var|, as an expression at evaluation will not have any free variables, as substitution will remove them. We can assume the argument to |eval| has no free variables. The free variables of a function are its arguments.

We also make use of a number of auxiliaries throughout the proof:

\begin{code}
isBottom, notBottom :: Expr -> Bool
isBottom Bottom = True
isBottom (Val c xs) = any isBottom xs

notBottom = not . isBottom

reduce' :: FuncName -> Prop (Sat VarName)
reduce' f = substP (args f) $ reduce (body f)

precond' :: FuncName -> Prop (Sat VarName)
precond' f = substP (args f) $ precond f

sat :: Prop (Sat Expr) -> Bool
sat (propTrue) = True
sat (propFalse) = False
sat (x `propOr` y) = sat x || sat y
sat (x `propAnd` y) = sat x && sat y
sat (propLit x) = satisfies x

satisfies :: Sat Expr -> Bool
\end{code}

Of these functions, |satisfies| is primitive and different for each constraint language. We assume |satisfies (Sat v k)| is always True, although in reality it never gets tried.

\subsection{Theorems}

We wish to prove:

\theorem{pre/eval}
{|sat (pre x) ==> notBottom (eval x)|}

In particular this requires the following theorems about the constraint language:

HERE THEY GO

We will also need the following general theorems:

\theorem{pre/subst}
{|sat (pre x / (freeVars x, ys_)) && all (sat . pre) ys_ ==> sat $ pre $ x / (freeVars x, ys_)|}

%\begin{code}
%(sat/all)       forall (xs :: [Sat Expr]) . sat (andP xs) == all (sat xs)
%(evalPre/evalSafe)    pre x ==> (evalPre x == evalSafe x)
%(error/precond)  f == "error" ==> not (satPrecond "error" xs)
%
%(satPrecond/sat)
%satPrecond f xs
%sat $ substP xs $ reduce (pre (body f))
%
%(subst/subst')
%substP xs y == subst' (zip vs xs) (substP vs y)
%-- provided length xs == length vs and all vs are otherwise not used
%
%reduce' = reduce but not changing var's to Int's
%subst' = subst but over a predicate
%
%(reduce/reduce')
%substP xs (reduce x) == subst' (zip vs xs) (reduce' x)
%where vs are the free variables in vs
%
%(sat/reduce)
%sat $ reduce x => sat x
%
%(sat/subst)
%sat x && all sat ys => sat $ subst (zip vs ys) x
%
%
%sat $ subst' sub
%\end{code}


\subsubsection{The Proof}

We prove each lemma in turn.

\proof{pre/eval}

By induction. We do not need to consider |Var| as |eval| cannot be called on expressions with free variables.

\proof[|Make|:]{pre/eval}

The initial definition is:

\begin{code}
eval (Make c xs_   ) = Val c (map eval xs_)
\end{code}

This does not produce |Bottom| if all recursive calls to |eval| are on values which satisfy |pre|. We can write this as:

\begin{code}
sat $ pre $ Make c xs_  ==> all (sat . pre) xs_
    -- inline |pre|
sat $ andP $ map pre xs_ ==> all (sat . pre) xs_
    -- inline |sat|
and $ map sat $ map pre xs_  ==> all (sat . pre) xs_
    -- |map f . map g == map (f . g)|
and $ map (sat . pre) xs_ ==> all (sat . pre) xs_
    -- |and . map f == all f|
all (sat . pre) xs_ ==> all (sat . pre) xs_
    -- equal
True
\end{code}

\proof[|Call|:]{pre/eval}

The initial definition is:

\begin{code}
eval (Call f xs_)  | f == "error" = Bottom
                   | otherwise = eval $ (body f)[args f / xs_]
\end{code}

We can use the theorem \lemma{pre/error} to show that |f| is never |"error"|, and the first alternative is never taken. This leaves us with the obligation that:

\begin{code}
sat $ pre $ Call f xs_ ==> sat $ pre $ (body f)[args f / xs_]
    -- inline pre on LHS
sat $ (precond' f) [args f / xs_] `propAnd` propAnds (map pre xs_) ==> sat $ pre $ (body f)[args f / xs_]
    -- inline |sat|
sat ((precond' f) [args f / xs_] && all (sat . pre) xs_ ==> sat $ pre $ (body f)[args f / xs_]
    -- \lemma{precond}
sat ((reduce' $ pre $ body f) [args f / xs_] && all (sat . pre) xs_ ==> sat $ pre $ (body f)[args f / xs_]
    -- \lemma{reduce}
sat ((pre $ body f) [args f / xs_] && all (sat . pre) xs_ ==> sat $ pre $ (body f)[args f / xs_]
    -- \lemma{sat/subst}
sat (pre $ body f) && all (sat . pre) xs_ ==> sat $ pre $ (body f)[args f / xs_]
    -- \lemma{pre/subst}
True
\end{code}

\proof[|Case|:]{pre/eval}

\begin{code}
eval (Case x as_  ) = case eval x of
    Val c xs_ -> eval $ head [y / (vs_, map uneval xs_) | Alt c' vs_ y <- as_, c == c']
    Bottom -> Bottom
\end{code}

This equation may generate |Bottom| in two ways -- either the explicit |Bottom| may be taken, or the nested |eval| may be taken. In both cases, if we can prove the expression passed to |eval| satisfies its precondition, then we can eliminate the possibility of |Bottom|.

We first prove that the explicit |Bottom| is not reached, assuming the initial expression does not violate the precondition check.

\begin{code}
sat $ pre $ Case x as_ ==> sat $ pre x
    -- inline |pre|
sat $ pre x `propAnd` andP (map alt as_) ==> sat $ pre x
    -- inline |sat|
sat (pre x) && andP (map alt as_) ==> sat $ pre x
    -- |a && b ==> a|
True
\end{code}

We now need to ensure that the other call to |eval| meets its precondition:

\begin{code}
sat $ pre $ Case x as_ ==> sat $ pre $ y / (vs_, map uneval xs_)
\end{code}

First we can work on the RHS only:

\begin{code}
sat $ pre $ y / (vs_, map uneval xs_)
    -- \lemma{pre/subst}
sat (pre y) && all (sat . pre) (map uneval xs)
    -- |all f . map g == all (f . g)|
sat (pre y) && all (sat . pre . uneval) xs
    -- \lemma{pre/uneval}
sat (pre y) && all (sat . const true) xs
    -- inline |sat|
sat (pre y) && all (const True) xs
    -- |all (const True) xs == True|
sat (pre y)
\end{code}

We can now return to the whole thing, assuming that the constructor is the first to be chosen:

\begin{code}
sat $ pre $ Case x (Alt c vs_ y : as_) ==> sat $ pre y
    -- inline |pre|
sat $ pre x `propAnd` propAnds (map alt (Alt c vs_ y : as_)) ==> sat $ pre y
    -- inline |sat|
sat (pre x) && all (sat . alt) (Alt c vs_ y : as_) ==> sat $ pre y
    -- inline |all|
sat (pre x) && sat (alt (Alt c vs_ y)) && all (sat . alt) as_ ==> sat $ pre y
    -- weaken the implication
sat $ alt $ Alt c vs_ y ==> sat $ pre y
    -- inline |alt|
sat $ x :< (ctors c \ [c]) `propOr` pre y ==> sat $ pre y
    -- inline |sat|
sat (x :< (ctors c \ [c]))) || sat (pre y) ==> sat $ pre y


sat (pre x) && all (sat .  `propAnd` andP (map alt as_) ==> sat $ pre y
    -- discard some information
sat $ alt $ Alt c vs y ==> pre y
    -- expand alt
x :< (ctors c \ [c]) 
\end{code}


\begin{code}



We can rewrite this as:

\begin{code}
sat (pre $ Case x as_) && c == c' ==> sat $ pre $ y / (vs_, map uneval xs_)

sat (pre x / (freeVars x, ys)


{|sat (pre x / (freeVars x, ys_)) && all (sat . pre) ys_ ==> sat $ pre $ x / (freeVars x, ys_)|}


eval $ head
\end{code}

We can assume c


This is safe if:

\begin{code}
sat $ pre (y [vs_ / xs_])
\end{code}

We can show that |xs_| is safe because it is the result of transforming |eval| over it. Therefore we have:

\begin{code}
c == c' && all (sat . pre) xs_ ==> sat $ pre (y [vs_ / xs_])
\end{code}

Need to continue here.




\subsection{Correctness of BP-constraints}


\subsection{Correctness of RE-constraints}


\subsection{Correctness of MP-constraints}

