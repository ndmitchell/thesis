%include thesis.fmt
%include catch.fmt

%format /# = "/"

\hsdef{\begin{comment}
k,f,c,v,i,on,xs_i,x,ys_i,s,a,ws
vs,xs,y,as,ys,cs
\end{comment}}
\begin{comment}
\begin{code}
import Prelude hiding (($),(/))
import Data.List

infixr 1  $
infixr 0  ==>
class Implies a where (==>) :: a -> a -> Bool
($) :: (a -> b) -> a -> b

instance Implies Bool
instance Implies (Prop a)

type FuncName = String
type CtorName = String
type VarName = String

freeVars :: Expr -> [String]
body   :: FuncName  -> Expr
args   :: FuncName  -> [VarName]
var    :: VarName   -> Maybe (Expr, Selector)
ctors  :: CtorName  -> [CtorName]
type Selector  =  (CtorName, Int)

precond   :: FuncName -> Prop (Sat VarName)
prePost   :: FuncName -> Constraint -> Prop (Sat VarName)
pre ::  Expr -> Prop (Sat Expr)
reduce    :: Prop (Sat Expr) -> Prop (Sat VarName)
red :: Expr -> Constraint -> Prop (Sat VarName)
substP :: Eq alpha => [(alpha,beta)] -> Prop (Sat alpha) -> Prop (Sat beta)

data Sat alpha = Sat alpha Constraint
instance Eq a => Eq (Sat a)

(-<)  :: alpha -> [CtorName] -> Prop (Sat alpha)
(|>)  :: Selector -> Constraint -> Constraint
(<|)  :: CtorName -> Constraint -> Prop (Sat Int)

data Prop alpha
instance Eq a => Eq (Prop a)

propAnd, propOr           :: Prop alpha -> Prop alpha -> Prop alpha
propAnds, propOrs         :: [Prop alpha] -> Prop alpha
propMap                   :: (alpha -> Prop beta) -> Prop alpha -> Prop beta
propTrue, propFalse       :: Prop alpha
propBool                  :: Bool -> Prop alpha
propLit                   :: alpha -> Prop alpha

data Constraint = Constraint

-- variable substitution, replacing free variables
class SubstVar a where (/) :: a -> ([VarName],[Expr]) -> a
instance SubstVar Expr
instance SubstVar Alt
instance SubstVar a => SubstVar (Sat a)
instance SubstVar a => SubstVar (Prop a)

-- equality substitution, replacing items
class SubstRep a b c | a c -> b, c b -> a, a b -> c where (/#) :: a -> b -> c
instance SubstRep (Prop (Sat Int)) ([Int], [Val]) (Prop (Sat Val))
instance SubstRep (Prop (Sat VarName)) ([VarName], [Expr]) (Prop (Sat Expr))
instance SubstRep VarName ([VarName], [Expr]) Expr
instance SubstRep (Prop (Sat Int)) ([Int], [Expr]) (Prop (Sat Expr))

instance Eq Val
instance Eq Expr

alt :: Alt -> Prop (Sat a)
pre' :: String -> [Expr] -> Prop (Sat Expr)
sub :: ([VarName],[Expr])
\end{code}
\end{comment}


\section{Argument for Correctness}
\label{secC:correct}

\newcommand{\lemma}[1]{(\textit{#1})}
\newcommand{\theorem}[2]{#2 \hspace{5mm} \lemma{#1} \\}
\newcommand{\proof}[2][]{\paragraph{\lemma{#2} \textsf{#1}}}

The algorithm is correct if given a function application whose arguments meet the precondition, it will not call |error|. The proof is structured as an evaluator with an explicit |Bottom| within it -- if this case is encountered the program will crash at runtime. We reason about the evaluator to show satisfying a precondition ensures that |Bottom| will not be reached. This corresponds to a proof of Figures \ref{figC:property_fixp}, \ref{figC:precondition}, \ref{figC:precond_fixp} and \ref{figC:prop}.

To perform the proof, we require various laws about the |-<|, | ||>| and |<||| operators, which we then show hold for each of the three constraint systems.

\subsection{Evaluator}

First we introduce functions and definitions which will be required later.

\begin{code}
data Val  =  Val CtorName [Val]
          |  Bottom

data Expr  =  Make CtorName [Expr]
           |  Call FuncName [Expr]
           |  Var  VarName
           |  Sel  Expr Selector
           |  Case Expr [Alt]

data Alt = Alt CtorName [VarName] Expr

eval :: Expr -> Val
eval (Sel x (c,i)) | c == c' = xs !! i
    where Val c' xs = eval x
eval (Make c xs   ) = Val c (map eval xs)
eval (Call f xs)  | f == "error" = Bottom
                  | otherwise = eval $ body f / (args f, xs)
eval (Case x as   ) = case eval x of
    Val c xs -> head [eval y | Alt c' vs y <- as, c == c']
    Bottom -> Bottom
\end{code}

We have introduced |Sel| for variables bound at a case expression. For the algorithm presented previously, the |Sel| constructor embodies the information returned by the |var| function. In the |Sel| alternative we know that the selector matches, and that we are beneath a |Case| on the same expression |x|. The behaviour of |eval| if there are free variables is undefined.

We make use of |(/)|, which we have redefined as a substitution operator -- we write |x / (vs,ys)| to denote replacing the free variables |vs| in |x| with |ys|. We use |(/)| instead of |substP| in the proofs. There is no |eval| alternative for |Var|, as an expression at evaluation will not have any free variables, as substitution will remove them. We can assume the argument to |eval| has no free variables. The free variables of a function are its arguments.

We assume the error function takes one argument and calls the error function.

We also make use of a number of auxiliaries throughout the proof:

\begin{code}
isBottom :: Val -> Bool
isBottom Bottom = True
isBottom (Val c xs) = any isBottom xs

valCtor :: Val -> Maybe CtorName
valCtor (Val c xs) = Just c
valCtor Bottom = Nothing

propIsTrue :: Prop () -> Bool
propIsTrue = (==) propTrue

propTaut :: (alpha -> Bool) -> Prop alpha -> Bool
propTaut f = propIsTrue . propMap (propBool . f)

satE' :: Prop (Sat Expr) -> Bool
satE' = propTaut satE

satE :: Sat Expr -> Bool
satE (Sat x k) = satV (eval x) k

satV' :: Prop (Sat Val) -> Bool
satV' = propTaut satV

satV :: Sat Val -> Bool
satV (Sat v k) = sat v k

sat :: Val -> Constraint -> Bool
\end{code}

Of these functions, |sat| is primitive and different for each constraint language. All the expressions given to |satE| must have no free variables, as |eval| cannot deal with them.

\subsection{Theorems}

We wish to prove:

\theorem{pre/eval}
{|satE' $ pre x ==> not $ isBottom $ eval x|}

In particular this requires the following theorems about the constraint language:

\theorem{satV/|-<|}
{|satV' $ x -< cs ==> maybe True (`elem` cs) (valCtor x)|}

\theorem{sat/| ||> |}
{|sat (Val c xs) ((c,i) ||> k) ==> sat (xs !! i) k|}

\theorem{sat/| <|| |}
{|satV' $ (c <|| k) /# ([0..],xs) ==> sat (Val c xs) k|}

We will also need the following general theorems:

\theorem{precond/error}
{|precond "error" == propFalse|}

\theorem{precond}
{|precond f ==> reduce $ pre $ body f|}

\theorem{reduce}
{|satE' $ reduce x /# sub ==> satE' $ x / sub|}

\theorem{red}
{|satE' $ red x k /# sub ==> sat (eval $ x / sub) k|}

\theorem{pre}
{|satE' (pre x / (vs, ys)) && all (satE' . pre) ys ==> satE' $ pre $ x / (vs, ys)|}

\theorem{satE/|-<|}
{|satV' (eval x -< cs) == satE' (x -< cs)|}

\theorem{elem}
{|(x `elem` (xs \\ [x])) == False|}

\subsubsection{The Proof}

We prove each lemma in turn.

\proof{pre/eval}

\h{expr}\begin{code}
satE' $ pre x ==> not $ isBottom $ eval x
\end{code}

By induction. We do not need to consider |Var| as |eval| cannot be called on expressions with free variables.

\proof[|Sel|:]{pre/eval}

The initial definition is:

\begin{code}
eval (Sel x (c,i)) | c == c' = xs !! i
    where Val c' xs = eval x
\end{code}

We know that any \ignore|Sel x _| value must be contained within a \ignore|Case x _| expression. If we assume that the original |Case| did satisfy its precondition, we obtain:

\h{exprlist}\begin{code}
satE' $ pre $ Case x as ==> satE' $ pre $ x
    -- inline |pre|
satE' $ pre x `propAnd` propAnds (map alt as) ==> satE' $ pre $ x
    -- inline |satE'|
satE' (pre x) && satE' (propAnds $ map alt as) ==> satE' $ pre $ x
    -- weaken implication
satE' $ pre x ==> satE' $ pre $ x
    -- equals
True
\end{code}

\proof[|Make|:]{pre/eval}

The initial definition is:

\begin{code}
eval (Make c xs) = Val c (map eval xs)
\end{code}

This does not produce |Bottom| if all recursive calls to |eval| are on values which satisfy |pre|. We can write this as:

\h{exprlist}\begin{code}
satE' $ pre $ Make c xs  ==> all (satE' . pre) xs
    -- inline |pre|
satE' $ propAnds $ map pre xs ==> all (satE' . pre) xs
    -- inline |satE'|
and $ map satE' $ map pre xs  ==> all (satE' . pre) xs
    -- |map f . map g == map (f . g)|
and $ map (satE' . pre) xs ==> all (satE' . pre) xs
    -- |and . map f == all f|
all (satE' . pre) xs ==> all (satE' . pre) xs
    -- equal
True
\end{code}

\proof[|Call|:]{pre/eval}

The initial definition is:

\begin{code}
eval (Call f xs)  | f == "error" = Bottom
                  | otherwise = eval $ body f / (args f, xs)
\end{code}

There are two ways to get |Bottom| from this fragment. The first is the explicit |Bottom|, and the second is the recursive call to |eval|. The first |Bottom| is avoided under the condition:

\h{exprlist}\begin{code}
satE' $ pre $ Call f xs ==> f /= "error"
    -- inline |pre|
satE' $ (precond f /# (args f, xs)) `propAnd` propAnds (map pre xs) ==> f /= "error"
    -- inline |satE'|
satE' (precond f /# (args f, xs)) && all (satE' . pre) xs ==> f /= "error"
    -- weaken implication
satE' (precond f /# (args f, xs)) ==> f /= "error"
\end{code}

We can now perform case analysis on |f|, assuming it either is, or is not, equal to |"error"|.

\h{exprlist}\begin{code}
satE' (precond f /# (args f, xs)) ==> f /= "error"
    -- assume |f /= "error"|
satE' (precond f /# (args f, xs)) ==> True
    -- implication
True
\end{code}

\h{exprlist}\begin{code}
satE' (precond f /# (args f, xs)) ==> f /= "error"
    -- assume |f == "error"|
satE' (precond f /# (args f, xs)) ==> False
    -- implication
not $ satE' (precond "error" /# (args f, xs))
    -- \lemma{precond/error}
not $ satE' $ (propFalse /# (args f, xs))
    -- inline |(/)|
not $ satE' propFalse
    -- inline |satE'|
not $ False
    -- inline |not|
True
\end{code}

This leaves us with the call to |eval|, namely:

\h{exprlist}\begin{code}
satE' $ pre $ Call f xs ==> satE' $ pre $ body f / (args f, xs)
    -- inline pre on LHS
satE' $ (precond f /# (args f, xs)) `propAnd` propAnds (map pre xs) ==> satE' $ pre $ body f / (args f, xs)
    -- inline |satE'|
satE' (precond f /# (args f, xs)) && all (satE' . pre) xs ==> satE' $ pre $ body f / (args f, xs)
    -- \lemma{precond}
satE' ((reduce $ pre $ body f) /# (args f, xs)) && all (satE' . pre) xs ==> satE' $ pre $ body f / (args f, xs)
    -- \lemma{reduce}
satE' (pre (body f) / (args f, xs)) && all (satE' . pre) xs ==> satE' $ pre $ body f / (args f, xs)
    -- \lemma{pre/subst}
True
\end{code}

\proof[|Case|:]{pre/eval}

\begin{code}
eval (Case x as   ) = case eval x of
    Val c xs -> head [eval y | Alt c' vs y <- as, c == c']
    Bottom -> Bottom
\end{code}

This equation may generate |Bottom| in two ways -- either the explicit |Bottom| may be taken, or the nested |eval| may be taken. In both cases, if we can prove the expression passed to |eval| satisfies its precondition, then we can eliminate the possibility of |Bottom|.

We first prove that the explicit |Bottom| is not reached, assuming the initial expression does not violate the precondition check.

\h{exprlist}\begin{code}
satE' $ pre $ Case x as ==> satE' $ pre x
    -- inline |pre|
satE' $ pre x `propAnd` propAnds (map alt as) ==> satE' $ pre x
    -- inline |satE'|
satE' (pre x) && satE' (propAnds $ map alt as) ==> satE' $ pre x
    -- weaken implication
satE' $ pre x ==> satE' $ pre x
    -- equal
True
\end{code}

We now need to ensure that the other call to |eval| meets its precondition.

\h{exprlist}\begin{code}
satE' $ pre $ Case x as ==> all (\(Alt c vs y) -> valCtor (eval x) == Just c ==> satE' $ pre y) as
    -- inline |pre|
satE' $ pre x `propAnd` propAnds (map alt as) ==> rhs
    -- inline |satE'|
satE' (pre x) && all (satE' . alt) as ==> rhs
    -- weaken implication
all (satE' . alt) as ==> all (\(Alt c vs y) -> valCtor (eval x) == Just c ==> satE' $ pre y) as
    -- lift implies over all
satE' $ alt a ==> (\(Alt c vs y) -> valCtor (eval x) == Just c ==> satE' $ pre y) a
    -- instantiate |a == Alt c v ys|
satE' $ alt $ Alt c v ys ==> (valCtor (eval x) == Just c ==> satE' $ pre y)
    -- inline |alt|
satE' (x -< (ctors c \\ [c]) `propOr` pre y) ==> rhs
    -- inline |satE'|
satE' (x -< (ctors c \\ [c])) || satE' (pre y) ==> rhs
    -- \lemma{satE/|-<|}
satV' (eval x -< (ctors c \\ [c])) || satE' (pre y) ==> rhs
    -- \lemma{satV/|-<|}
maybe True (`elem` (ctors c \\ [c])) (valCtor $ eval x) || satE' (pre y) ==> rhs
    -- using |valCtor (eval x) == c| from RHS
maybe True (`elem` (ctors c \\ [c])) (Just c) || satE' (pre y) ==> satE' $ pre y
    -- inline |maybe|
c `elem` (ctors c \\ [c]) || satE' (pre y) ==> satE' $ pre y
    -- \lemma{elem}
False || satE' (pre y) ==> satE' $ pre y
    -- inline |(||||)|
satE' $ pre y ==> satE' $ pre y
    -- equals
True
\end{code}


\proof{elem}

\h{expr}\begin{code}
(x `elem` (ys \\ [x])) == False
\end{code}

The |elem| application is only true if |ys \\ [x]| contains |x|. The expression cannot contain |x|, as if it existed in |ys| it was removed, therefore this application is always |False|.

\proof{precond/error}

\h{expr}\begin{code}
precond "error" == propFalse
\end{code}

The initial computation of |precond| will return |propFalse|. All successive computations will be at least as restrictive, therefore the result must be |propFalse|.

\proof{precond}

\h{expr}\begin{code}
precond f ==> reduce $ pre $ body f
\end{code}

The definition of |precond f| is a conjunction where the second conjunct is |reduce $ pre $ body f|, therefore |precond f| is at least as restrictive as the alternative.


\proof{satE/|-<|}

\h{exprlist}\begin{code}
satV' (eval x -< cs) == satE' (x -< cs)
    -- inline |satV'| and |satE'|
propTaut satV (eval x -< cs) == propTaut satE (x -< cs)
    -- inline |propTaut| and reduce common bits
propMap (propBool . satV) (eval x -< cs) == propMap (propBool . satE) (x -< cs)
\end{code}

Now we can use the type signature of |-<|:

\begin{code}
(-<) :: alpha -> [CtorName] -> Prop (Sat alpha)
\end{code}

The theorems for free work \cite{wadler:theorems} shows that the first argument will end up as the first argument of the |Sat| constructor, unmodified and unexamined. The |satE| function applies |eval| to the first argument of |Sat|, therefore both these pieces of code are equivalent.


\proof{pre}

\h{exprlist}\begin{code}
satE' (pre x / (vs, ys)) && all (satE' . pre) ys ==> satE' $ pre $ x / (vs, ys)
\end{code}

This proof is by case analysis on |x|. We assume that all free variables in |x| are bound in |vs|. To shorten all the proofs we hide the |all (satE' . pre) ys| term, as it is never manipulated.

\proof[|Var|:]{pre}

\h{exprlist}\begin{code}
satE' $ pre x / (vs, ys) ==> satE' $ pre $ x / (vs, ys)
    -- |x == Var v|
satE' $ pre (Var v) / (vs, ys) ==> satE' $ pre $ Var v / (vs, ys)
    -- inline |pre| on LHS
satE' $ propTrue / (vs, ys) ==> satE' $ pre $ Var v / (vs, ys)
    -- inline |(/)| on LHS
satE' propTrue ==> satE' $ pre $ Var v / (vs, ys)
    -- inline |satE'|
True ==> satE' $ pre $ Var v / (vs, ys)
    -- reintroduce hidden term
all (satE' . pre) ys ==> satE' $ pre $ Var v / (vs, ys)
\end{code}

We know that |v| will be a member of |vs|, and that the result will be |pre y|, where |y| is drawn from |ys|. Since all |ys| satisfy the precondition, then so will the particular |y| we substitute.

\proof[|Sel|:]{pre}

\h{exprlist}\begin{code}
satE' $ pre x / (vs, ys) ==> satE' $ pre $ x / (vs, ys)
    -- |x == Sel x s|
satE' $ pre (Sel x s) / (vs, ys) ==> satE' $ pre $ Sel x s / (vs, ys)
    -- inline |(/)| on RHS
satE' $ pre (Sel x s) / (vs, ys) ==> satE' $ pre $ Sel (x / (vs,ys)) s
    -- inline |pre| on RHS
satE' $ pre (Sel x s) / (vs, ys) ==> satE' $ propTrue
    -- inline |satE'| on RHS
satE' $ pre (Sel x s) / (vs, ys) ==> True
    -- implication
True
\end{code}

\proof[|Make|:]{pre}

\h{exprlist}\begin{code}
satE' $ pre x / (vs, ys) ==> satE' $ pre $ x / (vs, ys)
    -- |x == Make c xs|
satE' $ pre (Make c xs) / (vs, ys) ==> satE' $ pre $ Make c xs / (vs, ys)
    -- inline |(/)| on RHS
satE' $ pre (Make c xs) / (vs, ys) ==> satE' $ pre $ Make c $ map (/ (vs, ys)) xs
    -- inline |pre| on both sides
satE' $ propAnds (map pre xs) / (vs, ys) ==> satE' $ propAnds $ map (pre . (/ (vs, ys))) xs
    -- inline |(/)| on LHS
satE' $ propAnds $ map ((/ (vs,ys)) . pre) xs ==> satE' $ propAnds $ map (pre . (/ (vs, ys))) xs
    -- inline |satE'| on both sides
all (satE' . (/ (vs,ys)) . pre) xs ==> all (satE' . pre . (/ (vs, ys))) xs
    -- \lemma{pre}
True
\end{code}

\proof[|Call|:]{pre}

\h{exprlist}\begin{code}
satE' $ pre x / (vs, ys) ==> satE' $ pre $ x / (vs, ys)
    -- |x == Call f xs|
satE' $ pre (Call f xs) / (vs, ys) ==> satE' $ pre $ Call f xs / (vs, ys)
    -- inline |(/)| on RHS
satE' $ pre (Call f xs) / (vs, ys) ==> satE' $ pre $ Call f $ map (/ (vs, ys)) xs
\end{code}

Now we will work on each side individually, starting with LHS:

\h{exprlist}\begin{code}
satE' $ pre (Call f xs) / (vs, ys)
    -- inline |pre|
satE' $ (pre' f xs `propAnd` propAnds (map pre xs)) / (vs,ys)
    -- inline |(/)|
satE' $ (pre' f xs / (vs,ys)) `propAnd` propAnds (map (pre . (/ (vs,ys))) xs)
    -- inline |satE'|
satE' (pre' f xs / (vs,ys)) && all (satE' . pre . (/ (vs,ys))) xs
\end{code}

And the RHS:

\h{exprlist}\begin{code}
satE' $ pre $ Call f $ map (/ (vs, ys)) xs
    -- inline |pre|
satE' $ (pre' f (map (/ (vs, ys)) xs)) `propAnd` propAnds (map (pre . (/ (vs, ys))) xs)
    -- inline |satE'|
satE' (pre' f (map (/ (vs, ys)) xs)) && all (satE' . pre . (/ (vs, ys))) xs
\end{code}

We can now combine these sides, eliminating the common bit:

\h{exprlist}\begin{code}
satE' $ pre' f xs / (vs,ys) ==> satE' $ pre' f (map (/ (vs, ys)) xs)
    -- inline |pre'|
satE' $ (precond f /# (args f, xs)) / (vs,ys) ==> satE' $ precond f /# (args f, map (/ (vs, ys)) xs)
    -- using the knowledge that |precond f| only has the free variables |args f|
    -- we can inline |(/) on the left
satE' $ precond f /# (args f, map (/ (vs,ys)) xs) ==> satE' $ precond f /# (args f, map (/ (vs, ys)) xs)
    -- equal
True
\end{code}

\proof[|Case|:]{pre}

\h{exprlist}\begin{code}
satE' $ pre x / (vs, ys) ==> satE' $ pre $ x / (vs, ys)
    -- |x == Case x as|
satE' $ pre (Case x as) / (vs, ys) ==> satE' $ pre $ Case x as / (vs, ys)
    -- inline |(/)| on RHS
satE' $ pre (Case x as) / (vs, ys) ==> satE' $ pre $ Case (x / (vs, ys)) (map (/ (vs, ys)) as)
    -- inline |pre| on both sides
satE' $ (pre x `propAnd` propAnds (map alt as)) / (vs, ys) ==> satE' $ pre (x / (vs, ys)) `propAnd` propAnds (map (alt . (/ (vs, ys))) as)
    -- inline |(/)| on RHS
satE' $ (pre x / (vs, ys)) `propAnd` propAnds (map ((/ (vs, ys)) . alt) as)  ==> satE' $ pre (x / (vs, ys)) `propAnd` propAnds (map (alt . (/ (vs, ys))) as)
    -- inline |satE'|
satE' (pre x / (vs, ys)) && all (satE' . (/ (vs, ys)) . alt) as  ==> satE' (pre (x / (vs, ys))) && all (satE' . alt . (/ (vs, ys))) as
    -- \lemma{pre}
all (satE' . (/ (vs, ys)) . alt) as  ==> all (satE' . alt . (/ (vs, ys))) as
    -- implication over |all|
satE' $ alt a / (vs, ys) ==> satE' $ alt $ as / (vs, ys)
    -- instantiate |a| as a general |Alt|
satE' $ alt (Alt c ws y) / (vs, ys) ==> satE' $ alt $ Alt c ws y / (vs, ys)
    -- inline |(/)| on RHS
satE' $ alt (Alt c ws y) / (vs, ys) ==> satE' $ alt $ Alt c ws (y / (vs, ys))
    -- inline |alt|
satE' $ (x -< (ctors c \\ [c]) `propOr` pre y) / (vs, ys) ==> satE' $ (x / (vs,ys) -< (ctors c \\ [c])) `propOr` pre (y / (vs, ys))
    -- let |cs == ctors c \\ [c]
satE' $ (x -< cs `propOr` pre y) / (vs, ys) ==> satE' $ (x / (vs,ys) -< cs) `propOr` pre (y / (vs, ys))
    -- inline |(/)| on LHS
satE' $ (x / (vs,ys) -< cs) `propOr` (pre y / (vs, ys)) ==> satE' $ (x / (vs,ys) -< cs) `propOr` pre (y / (vs, ys))
    -- inline |satE'| on both sides
satE' (x / (vs,ys) -< cs) || satE' (pre y / (vs, ys)) ==> satE' (x / (vs,ys) -< cs) || satE' (pre (y / (vs, ys)))
    -- remove duplicate bits on each side
satE' $ pre y / (vs, ys) ==> satE' $ pre $ y / (vs, ys)
    -- \lemma{pre}
True
\end{code}


\proof{reduce}

We wish to prove:

\h{exprlist}\begin{code}
satE' $ reduce x /# sub ==> satE' $ x / sub
    -- inline |reduce|
satE' $ propMap (\(Sat x k) -> red x k) x /# sub ==> satE' $ x / sub
    -- inline |(/)| on LHS
satE' $ propMap (\(Sat x k) -> red x k /# sub) x ==> satE' $ x / sub
    -- inline |(/)| on RHS
satE' $ propMap (\(Sat x k) -> red x k /# sub) x ==> satE' $ propMap (\(Sat x k) -> propLit $ Sat x k / sub) x
    -- inline |(/)| on RHS
satE' $ propMap (\(Sat x k) -> red x k /# sub) x ==> satE' $ propMap (\(Sat x k) -> propLit $ Sat (x / sub) k) x
    -- inline |satE'|
propIsTrue $ propMap (\(Sat x k) -> propBool $ satE' $ red x k /# sub) x ==> propIsTrue $ propMap (\(Sat x k) -> propBool $ satE' $ propLit $ Sat (x / sub) k) x
    -- lift |propMap| over |(==>)|
satE' $ red x k /# sub ==> satE' $ propLit $ Sat (x / sub) k
    -- inline |satE'| on RHS
satE' $ red x k /# sub ==> satE $ Sat (x / sub) k
    -- inline |satE| on RHS
satE' $ red x k /# sub ==> sat (eval $ x / sub) k
    -- \lemma{red}
True
\end{code}


\proof{red}

We wish to prove:

\h{expr}\begin{code}
satE' $ red x k /# sub ==> sat (eval $ x / sub) k
\end{code}

We do so by case analysis on the expression |x|.

\proof[|Var|:]{red}

\h{exprlist}\begin{code}
satE' $ red x k /# sub ==> sat (eval $ x / sub) k
    -- |x == Var v|
satE' $ red (Var v) k /# sub ==> sat (eval $ Var v / sub) k
    -- inline |red|
satE' $ propLit (Sat v k) /# sub ==> sat (eval $ Var v / sub) k
    -- inline |(/)| on LHS
satE' $ propLit (Sat (v /# sub) k) ==> sat (eval $ Var v / sub) k
    -- promote |v| on LHS to |Var v|
    -- because |(/)| operates identically on both
satE' $ propLit (Sat (Var v / sub) k) ==> sat (eval $ Var v / sub) k
    -- inline |satE'|
satE (Sat (Var v / sub) k) ==> sat (eval $ Var v / sub) k
    -- inline |satE|
sat (eval $ Var v / sub) k ==> sat (eval $ Var v / sub) k
    -- equal
True
\end{code}

\proof[|Sel|:]{red}

For this section, we assume |eval (x / sub) == Val c xs|.

\h{exprlist}\begin{code}
satE' $ red x k /# sub ==> sat (eval $ x / sub) k
    -- |x == Sel x (c,i)|
satE' $ red (Sel x (c,i)) k /# sub ==> sat (eval $ Sel x (c,i) / sub) k
    -- inline |red|
satE' $ red x ((c,i) |> k) /# sub ==> sat (eval $ Sel x (c,i) / sub) k
    -- inline |(/)| on RHS
satE' $ red x ((c,i) |> k) /# sub ==> sat (eval $ Sel (x / sub) (c,i)) k
    -- inline |eval| on RHS
satE' $ red x ((c,i) |> k) /# sub ==> sat (xs !! i) k
    -- \lemma{sat/| ||> |}
satE' $ red x ((c,i) |> k) /# sub ==> sat (Val c xs) ((c,i) |> k)
    -- replace using the assumption
satE' $ red x ((c,i) |> k) /# sub ==> sat (eval (x / sub)) ((c,i) |> k)
    -- \lemma{red}
True
\end{code}

\proof[|Make|:]{red}

\h{exprlist}\begin{code}
satE' $ red x k /# sub ==> sat (eval $ x / sub) k
    -- |x == Make c xs|
satE' $ red (Make c xs) k /# sub ==> sat (eval $ Make c xs / sub) k
    -- inline |red|
satE' $ reduce ((c <| k) /# ([0..], xs)) /# sub ==> sat (eval $ Make c xs / sub) k
    -- \lemma{reduce}
satE' $ ((c <| k) /# ([0..], xs)) / sub ==> sat (eval $ Make c xs / sub) k
    -- inline |(/)| on LHS
satE' $ (c <| k) /# ([0..], map (/ sub) xs) ==> sat (eval $ Make c xs / sub) k
    -- inline |satE'| on LHS
satV' $ (c <| k) /# ([0..], map (eval . (/ sub)) xs) ==> sat (eval $ Make c xs / sub) k
    -- inline |(/)| on RHS
satV' $ (c <| k) /# ([0..], map (eval . (/ sub)) xs) ==> sat (eval $ Make c (map (/ sub) xs)) k
    -- inline |eval| on RHS
satV' $ (c <| k) /# ([0..], map (eval . (/ sub)) xs) ==> sat (Val c (map (eval . (/ sub)) xs)) k
    -- \lemma{sat/| <|| |}
sat (Val c (map (eval . (/ sub)) xs)) k ==> sat (Val c (map (eval . (/ sub)) xs)) k
    -- equal
True
\end{code}

\proof[|Call|:]{red}

\h{exprlist}\begin{code}
satE' $ red x k /# sub ==> sat (eval $ x / sub) k
    -- |x == Call f xs|
satE' $ red (Call f xs) k /# sub ==> sat (eval $ Call f xs / sub) k
    -- inline |red|
satE' $ reduce (prePost f k /# (args f, xs)) /# sub ==> sat (eval $ Call f xs / sub) k
    -- \lemma{reduce}
satE' $ (prePost f k /# (args f, xs)) / sub ==> sat (eval $ Call f xs / sub) k
    -- inline |(/)| on LHS
satE' $ prePost f k /# (args f, map (/sub) xs) ==> sat (eval $ Call f xs / sub) k
    -- \lemma{prePost}
satE' $ reduce (propLit $ Sat (body f) k) /# (args f, map (/sub) xs) ==> sat (eval $ Call f xs / sub) k
    -- \lemma{reduce}
satE' $ (propLit $ Sat (body f) k) / (args f, map (/sub) xs) ==> sat (eval $ Call f xs / sub) k
    -- inline |(/)| on LHS
satE' $ (propLit $ Sat (body f / (args f, map (/sub) xs)) k) ==> sat (eval $ Call f xs / sub) k
    -- inline |satE'|
satE $ Sat (body f / (args f, map (/sub) xs)) k ==> sat (eval $ Call f xs / sub) k
    -- inline |satE|
sat (eval $ body f / (args f, map (/sub) xs)) k ==> sat (eval $ Call f xs / sub) k
    -- inline |(/)| on RHS
sat (eval $ body f / (args f, map (/sub) xs)) k ==> sat (eval $ Call f (map (/ sub) xs)) k
\end{code}

We now split and assume that either |f| is equal to error, or not. First we consider the case where |f == "error"|.

\h{exprlist}\begin{code}
sat (eval $ body f / (args f, map (/ sub) xs)) k ==> sat (eval $ Call f (map (/ sub) xs)) k
    -- assume |f == "error"|
sat (eval $ body "error" / (args f, map (/ sub) xs)) k ==> sat (eval $ Call "error" (map (/ sub) xs)) k
    -- inline |RHS|
sat (eval $ body "error" / (args f, map (/ sub) xs)) k ==> sat Bottom k
    -- assume |error x = error x|
sat (eval $ Call "error" [Var "x"] / (["x"], map (/sub) xs)) k ==> sat Bottom k
    -- inline |(/)| on LHS
sat (eval $ Call "error" [head xs / sub]) k ==> sat Bottom k
    -- inline |eval|
sat Bottom k ==> sat Bottom k
    -- equal
True
\end{code}

\h{exprlist}\begin{code}
sat (eval $ body f / (args f, map (/ sub) xs)) k ==> sat (eval $ Call f (map (/ sub) xs)) k
    -- inline |eval| on RHS
sat (eval $ body f / (args f, map (/ sub) xs)) k ==> sat (eval $ body f / (args f, map (/ sub) xs)) k
    -- equal
True
\end{code}

%if 0

\proof[|Case|:]{red}

\h{exprlist}\begin{code}
satE' $ red x k /# sub ==> sat (eval $ x / sub) k
    -- |x == Case x as|
satE' $ red (Case x as) k /# sub ==> sat (eval $ Case x as / sub) k
    -- inline |red|
satE' $ andP (map alt as) /# sub ==> sat (eval $ Case x as / sub) k
    -- inline |(/)| on LHS
satE' $ andP $ map ((/# sub) . alt) as ==> sat (eval $ Case x as / sub) k
    -- inline |satE'|
all (satE' . (/# sub) . alt) as ==> sat (eval $ Case x as / sub) k



\subsection{Correctness of BP-constraints}


\subsection{Correctness of RE-constraints}


\subsection{Correctness of MP-constraints}

