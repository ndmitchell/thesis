%include thesis.fmt
%include catch.fmt

\hsdef{\begin{comment}
k,vs,zs,xs,f,c,v,i,on,xs_i,ys,x,ys_i
vs_,xs_,y,as_,alt,ys_,cs
\end{comment}}
\begin{comment}
\begin{code}
import Prelude hiding (($),(/))
import Data.List

infixr 1  $
infixr 0  ==>
(==>) :: Bool -> Bool -> Bool
($) :: (a -> b) -> a -> b

type FuncName = String
type CtorName = String
type VarName = String

freeVars :: Expr -> [String]
body   :: FuncName  -> Expr
args   :: FuncName  -> [VarName]
argsN :: FuncName -> [Int]
var    :: VarName   -> Either ArgPos (Expr, Selector)
ctors  :: CtorName  -> [CtorName]
type Selector  =  (CtorName, Int)
type ArgPos    =  Int

precond   :: FuncName -> Prop (Sat ArgPos)
prePost   :: FuncName -> Constraint -> Prop (Sat ArgPos)
pre ::  Expr -> Prop (Sat Expr)
reduce    :: Prop (Sat Expr) -> Prop (Sat ArgPos)
red :: Expr -> Constraint -> Prop (Sat ArgPos)
substP ::  [alpha] -> Prop (Sat ArgPos) -> Prop (Sat alpha)

data Sat alpha = Sat alpha Constraint

(-<)  :: alpha -> [CtorName] -> Prop (Sat alpha)
(|>)  :: Selector -> Constraint -> Constraint
(<|)  :: CtorName -> Constraint -> Prop (Sat ArgPos)

data Prop alpha
instance Eq a => Eq (Prop a)

propAnd, propOr           :: Prop alpha -> Prop alpha -> Prop alpha
propAnds, propOrs         :: [Prop alpha] -> Prop alpha
propMap                   :: (alpha -> Prop beta) -> Prop alpha -> Prop beta
propTrue, propFalse       :: Prop alpha
propBool                  :: Bool -> Prop alpha
propLit                   :: alpha -> Prop alpha

data Constraint = Constraint

class Subst a b c where (/) :: a -> b -> c
class SubstNum a b c where (/#) :: a -> b -> c

instance Subst Expr ([VarName], [Expr]) Expr
\end{code}
\end{comment}


\section{Argument for Correctness}
\label{secC:correct}

\newcommand{\lemma}[1]{(\textit{#1})}
\newcommand{\theorem}[2]{#2 \hspace{5mm} \lemma{#1} \\}
\newcommand{\proof}[2][]{\paragraph{\lemma{#2} \textsf{#1}}}

The algorithm is correct if given a function application whose arguments meet the precondition, it will not call |error|. The proof is structured as an evaluator with an explicit |Bottom| within it -- if this case is encountered the program will crash at runtime. We reason about the evaluator to show satisfying a precondition ensures that |Bottom| will not be reached. This corresponds to a proof of Figures \ref{figC:property_fixp}, \ref{figC:precondition}, \ref{figC:precond_fixp} and \ref{figC:prop}.

To perform the proof, we require various laws about the |-<|, | ||>| and |<||| operators, which we then show hold for each of the three constraint systems.

\subsection{Evaluator}

First we introduce functions and definitions which will be required later.

\begin{code}
data Val  =  Val CtorName [Val]
          |  Bottom

data Expr  =  Make CtorName [Expr]
           |  Call FuncName [Expr]
           |  Var  VarName
           |  Case Expr [Alt]

data Alt = Alt CtorName [VarName] Expr

eval :: Expr -> Val
eval (Make c xs_   ) = Val c (map eval xs_)
eval (Call f xs_)  | f == "error" = Bottom
                   | otherwise = eval $ body f / (args f, xs_)
eval (Case x as_  ) = case eval x of
    Val c xs_ -> eval $ head [y / (vs_, map uneval xs_) | Alt c' vs_ y <- as_, c == c']
    Bottom -> Bottom

uneval :: Val -> Expr
uneval (Val c xs_)  = Make c (map uneval xs_)
uneval Bottom       = Call "error" []
\end{code}

We make use of |(/)|, which we have redefined as a substitution operator -- we write |x / (vs_,ys_)| to denote replacing the free variables |vs_| in |x| with |ys_|. If the value |x| has numbers instead of free variables, we write |x /# (vs_,ys_)|, where |vs_| are a sequence of numbers. There is no |eval| alternative for |Var|, as an expression at evaluation will not have any free variables, as substitution will remove them. We can assume the argument to |eval| has no free variables. The free variables of a function are its arguments.

We also make use of a number of auxiliaries throughout the proof:

\begin{code}
isBottom :: Val -> Bool
isBottom Bottom = True
isBottom (Val c xs) = any isBottom xs

valCtor :: Val -> Maybe CtorName
valCtor (Val c xs_) = Just c
valCtor Bottom = Nothing

propTaut :: (alpha -> Bool) -> Prop alpha -> Bool
propTaut f x = (propTrue :: Prop ()) == propMap (propBool . f) x

satP :: Prop (Sat Expr) -> Bool
satP = propTaut satS

satS :: Sat Expr -> Bool
satS (Sat x k) = sat (eval x) k

sat :: Val -> Constraint -> Bool
\end{code}

Of these functions, |sat| is primitive and different for each constraint language. All the expressions given to |satS| must have no free variables, as |eval| cannot deal with them.

\subsection{Theorems}

We wish to prove:

\theorem{pre/eval}
{|satP $ pre x ==> not $ isBottom $ eval x|}

In particular this requires the following theorems about the constraint language:

\theorem{sat/|-<|}
{|sat $ x -< cs ==> any (hasCtor x) cs|}

\theorem{sat/| ||> |}
{|sats (Val c xs) ((c,i) ||> k) ==> sats (xs !! i) k|}

\theorem{sat/| <|| |}
{|sats (c <|| k /# (xs, xs)) ==> sat (c xs) k|}

We will also need the following general theorems:

\theorem{precond/error}
{|precond "error" == propFalse|}

\theorem{precond}
{|precond f ==> reduce $ pre $ body f|}

\theorem{reduce}
{|sat (reduce x /# (vs, xs)) ==> sat (x / (vs, xs))|}


\theorem{pre/subst}
{|sat (pre x) && all (sat . pre) ys_ ==> sat $ pre $ x / (freeVars x, ys_)|}

\theorem{sat/subst}
{|sat (pre x / (freeVars x, ys_)) && all (sat . pre) ys_ ==> sat $ pre $ x / (freeVars x, ys_)|}

\theorem{pre/uneval}
{|not $ isBottom x ==> sat (pre (uneval x))|}


\subsubsection{The Proof}

We prove each lemma in turn.

\proof{pre/eval}

By induction. We do not need to consider |Var| as |eval| cannot be called on expressions with free variables.

\proof[|Make|:]{pre/eval}

The initial definition is:

\begin{code}
eval (Make c xs_) = Val c (map eval xs_)
\end{code}

This does not produce |Bottom| if all recursive calls to |eval| are on values which satisfy |pre|. We can write this as:

\h{exprlist}\begin{code}
sat $ pre $ Make c xs_  ==> all (sat . pre) xs_
    -- inline |pre|
sat $ propAnd $ map pre xs_ ==> all (sat . pre) xs_
    -- inline |sat|
and $ map sat $ map pre xs_  ==> all (sat . pre) xs_
    -- |map f . map g == map (f . g)|
and $ map (sat . pre) xs_ ==> all (sat . pre) xs_
    -- |and . map f == all f|
all (sat . pre) xs_ ==> all (sat . pre) xs_
    -- equal
True
\end{code}

\proof[|Call|:]{pre/eval}

The initial definition is:

\begin{code}
eval (Call f xs_)  | f == "error" = Bottom
                   | otherwise = eval $ (body f)[args f / xs_]
\end{code}

There are two ways to get |Bottom| from this fragment. The first is the explicit |Bottom|, and the second is the recursive call to |eval|. The first |Bottom| is avoided under the condition:

\h{exprlist}\begin{code}
sat $ pre $ Call f xs_ ==> f /= "error"
    -- inline |pre|
sat $ substP xs (precond f) `propAnd` propAnds (map pre xs_) ==> f /= "error"
    -- inline |sat|
sat (substP xs (precond f)) && all (sat . pre) xs_ ==> f /= "error"
    -- weaken implication
sat (substP xs (precond f)) ==> f /= "error"
\end{code}

We can now perform case analysis on |f|, assuming it either is, or is not, equal to |"error"|.

\h{exprlist}\begin{code}
sat (substP xs (precond f)) ==> f /= "error"
    -- assume |f /= "error"|
sat (substP xs (precond f)) ==> True
    -- implication
True
\end{code}

\h{exprlist}\begin{code}
sat (substP xs (precond f)) ==> f /= "error"
    -- assume |f == "error"|
sat (substP xs (precond "error")) ==> False
    -- implication
not $ sat $ substP xs $ precond "error"
    -- \lemma{precond/error}
not $ sat $ substP xs $ propFalse
    -- inline |substP|
not $ sat $ propFalse
    -- inline |sat|
not $ False
    -- inline |not|
True
\end{code}

This leaves us with the call to |eval|, namely:

\h{exprlist}\begin{code}
sat $ pre $ Call f xs_ ==> sat $ pre $ body f / (args f, xs)
    -- inline pre on LHS
sat $ (precond f / (args f /# xs_)) `propAnd` propAnds (map pre xs_) ==> sat $ pre $ body f / (args f, xs)
    -- inline |sat|
sat (precond f / (args f /# xs_)) && all (sat . pre) xs_ ==> sat $ pre $ body f / (args f, xs)
    -- \lemma{precond}
sat ((reduce $ pre $ body f) / (args f /# xs_)) && all (sat . pre) xs_ ==> sat $ pre $ body f / (args f, xs)
    -- \lemma{reduce}
sat (pre (body f) / (args f / xs_)) && all (sat . pre) xs_ ==> sat $ pre $ body f / (args f, xs)
    -- \lemma{pre/subst}
True
\end{code}


\h{exprlist}\begin{code}
sat ((reduce $ pre $ body f) / (argsN f / xs_)) && all (sat . pre) xs_ ==> sat $ pre $ body f / (args f, xs)
\end{code}

We can now do case analysis on the body of f.

\h{exprlist}\begin{code}
    -- body f == Var v
sat ((reduce $ pre $ Var v) / (argsN f / xs_)) && all (sat . pre) xs_ ==> sat $ pre $ v / (args f, xs)
    -- apply the substitution
sat ((reduce $ pre $ Var v) / (argsN f / xs_)) && all (sat . pre) xs_ && y `elem` xs ==> sat $ pre y
    -- weaken the precondition
all (sat . pre) xs_ && y `elem` xs ==> sat $ pre y
    -- \lemma{all/elem}
sat $ pre y ==> sat $ pre y
    -- implication
True
\end{code}

\h{exprlist}\begin{code}
    -- body f == Make c ys
sat ((reduce $ pre $ Make c ys) / (argsN f, xs_)) && all (sat . pre) xs_ ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |pre| on RHS
sat ((reduce $ propAnd $ map pre ys) / (argsN f, xs_)) && all (sat . pre) xs_ ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |reduce|
sat (propAnds (map (reduce . pre) ys) / (argsN f, xs_)) && all (sat . pre) xs_ ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |(/)| on LHS
sat (propAnds (map ((/ (argsN f, xs_)) . reduce . pre) ys)) && all (sat . pre) xs_ ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |sat|
all (sat . ((/ (argsN f, xs_)) . reduce . pre) ys) && all (sat . pre) xs_ ==> sat $ pre $ Make c ys / (args f, xs)
    -- inline |(/)| on RHS
all (sat . ((/ (argsN f, xs_)) . reduce . pre) ys) && all (sat . pre) xs_ ==> sat $ pre $ Make c $ map (/ (args f, xs)) ys
    -- inline |pre| on RHS
all (sat . ((/ (argsN f, xs_)) . reduce . pre) ys) && all (sat . pre) xs_ ==> all (sat. pre . (/ (args f, xs))) ys
    -- inductive hypothesis
True
\end{code}




\h{exprlist}\begin{code}
all (sat . reduce . pre) ys sat (propAnds (map (reduce . pre) ys) / (argsN f / xs_)) && all (sat . pre) xs_ ==> sat $ pre $ Make c ys / (args f, xs)

sat ((reduce $ pre $ Make c ys) / (argsN f / xs_)) && all (sat . pre) xs_ ==> sat $ pre $ Make c ys / (args f, xs)
\end{code}


\proof[|Case|:]{pre/eval}

\begin{code}
eval (Case x as_  ) = case eval x of
    Val c xs_ -> eval $ head [y / (vs_, map uneval xs_) | Alt c' vs_ y <- as_, c == c']
    Bottom -> Bottom
\end{code}

This equation may generate |Bottom| in two ways -- either the explicit |Bottom| may be taken, or the nested |eval| may be taken. In both cases, if we can prove the expression passed to |eval| satisfies its precondition, then we can eliminate the possibility of |Bottom|.

We first prove that the explicit |Bottom| is not reached, assuming the initial expression does not violate the precondition check.

\h{exprlist}\begin{code}
sat $ pre $ Case x as_ ==> sat $ pre x
    -- inline |pre|
sat $ pre x `propAnd` propAnd (map alt as_) ==> sat $ pre x
    -- inline |sat|
sat (pre x) && propAnd (map alt as_) ==> sat $ pre x
    -- weaken implication
sat $ pre x ==> sat $ pre x
    -- equal
True
\end{code}

We now need to ensure that the other call to |eval| meets its precondition:

\h{exprlist}\begin{code}
sat (pre (Case x as_)) && (eval x == Val c xs_) ==> sat $ pre $ y / (vs_, map uneval xs_)
\end{code}

First we can work on the RHS only:

\h{exprlist}\begin{code}
sat $ pre $ y / (vs_, map uneval xs_)
    -- \lemma{pre/subst}
sat (pre y / (vs_, map uneval xs)) && all (sat . pre) (map uneval xs)
    -- |all f . map g == all (f . g)|
sat (pre y / (vs_, map uneval xs)) && all (sat . pre . uneval) xs
    -- \lemma{pre/uneval}
sat (pre y / (vs_, map uneval xs)) && all (sat . const propTrue) xs
    -- inline |sat|
sat (pre y / (vs_, map uneval xs)) && all (const True) xs
    -- |all (const True) xs == True|
sat (pre y / (vs_, map uneval xs))
\end{code}

We can now return to the whole thing, assuming that the constructor is the first to be chosen. We can reorder the alternatives because they have no order and are processed in a map in the code. We can assume that |x| matches \ignore|Val c _| because that branch has been picked.

\h{exprlist}\begin{code}
sat $ pre $ Case x (Alt c vs_ y : as_) ==> sat $ pre y
    -- inline |pre|
sat $ pre x `propAnd` propAnds (map alt (Alt c vs_ y : as_)) ==> sat $ pre y
    -- inline |sat|
sat (pre x) && all (sat . alt) (Alt c vs_ y : as_) ==> sat $ pre y
    -- inline |all|
sat (pre x) && sat (alt (Alt c vs_ y)) && all (sat . alt) as_ ==> sat $ pre y
    -- weaken the implication
sat $ alt $ Alt c vs_ y ==> sat $ pre y
    -- inline |alt|
sat $ x -< (ctors c \\ [c]) `propOr` pre y ==> sat $ pre y
    -- inline |sat|
sat (x -< (ctors c \\ [c])) || sat (pre y) ==> sat $ pre y
    -- \lemma{sat/|-<|}
ctor x `elem` (ctors c \\ [c]) || sat (pre y) ==> sat $ pre y
    -- |ctor x == c|
c `elem` (ctors c \\ [c]) || sat (pre y) ==> sat $ pre y
    -- \lemma{elem/diff}
False || sat (pre y) ==> sat $ pre y
    -- inline |(||||)|
sat $ pre y ==> sat $ pre y
    -- implication
True
\end{code}


\proof{elem/diff}

\h{exprlist}\begin{code}
(x `elem` (ys \\ [x])) == False
\end{code}

The |elem| application is only true if |ys \\ [x]| contains |x|. The expression cannot contain |x|, as if it existed in |ys| it was removed, therefore this application is always |False|.


\theorem{precond/error}
{|precond "error" == propFalse|}


\theorem{precond}
{|precond f ==> reduce $ pre $ body f|}


\proof{sat/reduce}

\ignore\begin{code}
reduce

sat (reduce' x) ==> sat x
    -- inline reduce'
sat reduce $
reduce' :: FuncName -> Prop (Sat VarName)
reduce' f = substP (args f) $ reduce (body f)




sat ((reduce $ pre $ body f) / (argsN f / xs_)) && all (sat . pre) xs_ ==> sat $ pre $ body f / (args f, xs)
    -- \lemma{reduce}
sat (pre (body f) / (args f / xs_)) && all (sat . pre) xs_ ==> sat $ pre $ body f / (args f, xs)
\end{code}





\proof{reduce}

\theorem{reduce}
{|sat (reduce x /# (vs, xs)) ==> sat (x / (vs, xs))|}

\h{exprlist}\begin{code}
sat (reduce x /# (vs, xs)) ==> sat (x / (vs, xs))
    -- inline |reduce|
sat (propMap (\(Sat x k) -> red x k) x /# (vs, xs)) ==> sat (x / (vs, xs))
    -- inline |(/#)| on LHS
sat (propMap (\(Sat x k) -> red x k /# (vs, xs)) x) ==> sat (x / (vs, xs))
    -- promote |sat|
propBool $ propMap (\(Sat x k) -> sat $ red x k /# (vs, xs)) x ==> sat (x / (vs, xs))
    -- \lemma{red}
propBool $ propMap (\(Sat x k) -> sat $ red x k /# (vs, xs)) x ==> propBool $ propMap

\end{code}

\ignore\begin{code}
let foo = (\(Sat x k) -> red x k /# (vs, xs))

sat (propMap foo x) ==> sat (x / (vs, xs))


sat (propMap (f . (/# (vs,xs))) x) ==> sat (x / (vs, xs))
\end{code}

\proof{red}

\theorem{red}
{|sat (red x k /# (vs, xs)) ==> satisfies (x / (vs, xs)) k|}

By induction on x:

\proof[|Var|:]{red}

Now, either |var v| is equal to |Left i| or |Right (on,c)|. We deal with each case in turn.

\h{exprlist}\begin{code}
sat (red v k /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- inline |red|, assuming |var v == Left i|
sat (propLit (Sat i k) /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- inline both substitutions
sat (propLit (Sat x k)) ==> satisfies x k
    -- inline |sat|
satisfies x k ==> satisfies x k
    -- implication
True
\end{code}

Now lets assume it is equal to the |Right|. If |var v == Right (on,(c,i))|, we therefore know that |v| is not a free variable, and the substitution |(/)| will not apply. We also know that |on == Val c xs|, where |xs_i == v|.

\h{exprlist}\begin{code}
sat (red v k /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- inline |red|, assuming |var v == Right (on,(c,i))|
sat (red on ((c,i) |> k) /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- knowledge about |on == Val c xs|
sat (red (Make c ys) ((c,i) |> k) /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- \lemma{| ||> |}
sat (red ys_i k /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- knowledge that |ys_i == v|
sat (red v k /# (vs, xs)) ==> satisfies (v / (vs, xs)) k
    -- \lemma{red}
sat (v / (vs, xs)) k ==> satisfies (v / (vs, xs)) k
    -- equals
True
\end{code}

\proof[|Make|:]{red}

\h{exprlist}\begin{code}
sat (red (Make c xs) k /# (vs, zs)) ==> satisfies (Make c xs / (vs, zs)) k
    -- inline |red|
sat (reduce ((c <| k) /# xs) /# (vs, zs)) ==> satisfies (Make c xs / (vs, zs)) k
    -- \lemma{reduce}
sat (((c <| k) /# xs) / (vs, zs)) ==> satisfies (Make c xs / (vs, zs)) k
    -- \lemma{sat/| <|| |}
sat (Val c xs / (vs, zs)) k ==> satisfies (Make c xs / (vs, zs)) k
    -- continue
\end{code}

\proof[|Call|:]{red}

\h{exprlist}\begin{code}
sat (red (Call f xs) k /# (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- inline |red|
sat (reduce (prePost f k /# xs) /# (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{reduce}
sat ((prePost f k /# xs) / (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{prePost}
sat ((reduce (body f `Sat` k) /# xs) / (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{reduce}
    -- continue
\end{code}

\proof[|Case|:]{red}

\h{exprlist}\begin{code}
sat (red (Call f xs) k /# (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- inline |red|
sat (reduce (prePost f k /# xs) /# (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{reduce}
sat ((prePost f k /# xs) / (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{prePost}
sat ((reduce (body f `Sat` k) /# xs) / (vs, zs)) ==> satisfies (Call f xs / (vs, zs)) k
    -- \lemma{reduce}
    -- continue
\end{code}





\subsection{Correctness of BP-constraints}


\subsection{Correctness of RE-constraints}


\subsection{Correctness of MP-constraints}

